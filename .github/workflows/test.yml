name: A内核编译

permissions:
  contents: read # Default to read for most jobs. create_release job will override.

concurrency:
  group: kernel-build-${{ github.ref }}-${{ github.event.inputs.kernel_to_build }}
  cancel-in-progress: true

on:
  workflow_dispatch:
    inputs:
      kernel_to_build:
        description: "选择内核版本"
        required: true
        type: choice
        options:
          - "android12_5.10_168_2023-04_r9"
          - "android12_5.10_198_2024-01_r17"
          - "android12_5.10_205_2024-03_r9"
          - "android12_5.10_209_2024-05_r13"
          - "android12_5.10_218_2024-08_r14"
          - "android12_5.10_226_2024-11_r8"
          - "android12_5.10_233_2025-02_r1"
          - "android12_5.10_X_lts_r1"
          - "android13_5.10_198_2024-01_"
          - "android13_5.10_205_2024-03_"
          - "android13_5.10_209_2024-05_"
          - "android13_5.10_214_2024-07_"
          - "android13_5.10_218_2024-08_"
          - "android13_5.10_223_2024-11_"
          - "android13_5.10_228_2025-01_"
          - "android13_5.10_X_lts_"
          - "android13_5.15_123_2023-11_"
          - "android13_5.15_137_2024-01_"
          - "android13_5.15_144_2024-03_"
          - "android13_5.15_148_2024-05_"
          - "android13_5.15_151_2024-08_"
          - "android13_5.15_167_2024-11_"
          - "android13_5.15_170_2025-01_"
          - "android13_5.15_X_lts_"
          - "android14_5.15_131_2023-11_"
          - "android14_5.15_137_2024-01_"
          - "android14_5.15_144_2024-03_"
          - "android14_5.15_148_2024-05_"
          - "android14_5.15_149_2024-06_"
          - "android14_5.15_153_2024-07_"
          - "android14_5.15_158_2024-08_"
          - "android14_5.15_167_2024-11_"
          - "android14_5.15_170_2025-01_"
          - "android14_6.1_75_2024-05_"
          - "android15_6.6_50_2024-10_"
          - "android15_6.6_56_2024-11_"
          - "android15_6.6_57_2024-12_"
          - "android15_6.6_58_2025-01_"
          - "android15_6.6_66_2025-02_"
          - "android15_6.6_77_2025-03_"
          - "android15_6.6_X_lts_"
        default: "android14_6.1_75_2024-05_"
      kernelsu_branch:
        description: "选择SukiSU功能分支"
        required: true
        type: choice
        options:
          - Stable
          - Dev
          - Other
        default: Dev
      custom_version_suffix:
        description: '自定义内核版本后缀 (留空仿官方)'
        required: false
        type: string
      use_zram:
        description: '启用额外ZRAM算法'
        required: true
        type: boolean
        default: true
      use_kpm:
        description: '启用KPM功能'
        required: true
        type: boolean
        default: true
      upload_to_release:
        description: '是否上传到 GitHub Release'
        required: true
        type: choice
        options:
          - 'true'
          - 'false'
        default: 'true'

jobs:
  determine_sukisu_version:
    name: 获取SukiSU版本
    runs-on: ubuntu-latest
    outputs:
      job_name_suffix: ${{ steps.calculate_version.outputs.job_suffix }}
      sukisu_version: ${{ steps.calculate_version.outputs.suki_version_actual }}
    steps:
      - name: 安装Git
        run: sudo DEBIAN_FRONTEND=noninteractive apt-get update -qq && sudo DEBIAN_FRONTEND=noninteractive apt-get install -yq --no-install-recommends git
      - name: 计算SukiSU版本号
        id: calculate_version
        shell: bash
        run: |
          set -euo pipefail
          suki_version_actual_for_output="获取失败"
          job_suffix_text=""
          SUKI_REPO_URL="https://github.com/ShirkNeko/SukiSU-Ultra.git"
          CLONE_BRANCH="main" # Assuming SukiSU uses 'main' for version calculation base
          echo "Attempting to clone SukiSU from $SUKI_REPO_URL branch $CLONE_BRANCH..."
          if git clone --branch "$CLONE_BRANCH" --single-branch "$SUKI_REPO_URL" SukiSU_temp_for_version; then
            cd SukiSU_temp_for_version
            commit_count=$(git rev-list --count HEAD 2>/dev/null || echo "err_count")
            if [[ "$commit_count" != "err_count" && "$commit_count" =~ ^[0-9]+$ ]]; then
              calculated_version=$((commit_count + 10606)) # Original logic: expr $commit_count + 10606
              suki_version_actual_for_output=$calculated_version
              job_suffix_text=" (SukiSU $calculated_version)"
              echo "SukiSU version calculated: $calculated_version"
            else
              suki_version_actual_for_output="计算错误"
              job_suffix_text=" (SukiSU - 版本计算失败)"
              echo "::warning::Failed to calculate SukiSU commit count. Git count output: $commit_count"
            fi
            cd ..
            rm -rf SukiSU_temp_for_version
          else
            suki_version_actual_for_output="克隆错误"
            job_suffix_text=" (SukiSU - 克隆失败)"
            echo "::error::Failed to clone SukiSU repository for version calculation."
            # exit 1 # Decide if this is a critical failure for the whole workflow
          fi
          echo "job_suffix=${job_suffix_text}" >> $GITHUB_OUTPUT
          echo "suki_version_actual=${suki_version_actual_for_output}" >> $GITHUB_OUTPUT
          echo "SukiSU version determination completed. Actual: $suki_version_actual_for_output, Suffix: $job_suffix_text"

  build_kernel:
    name: 内核编译 (SukiSU) - ${{ github.event.inputs.kernel_to_build }}${{ needs.determine_sukisu_version.outputs.job_name_suffix }}
    needs: determine_sukisu_version
    runs-on: ubuntu-latest
    # permissions: default (read)
    outputs:
      artifact_name: ${{ steps.prepare_release_outputs.outputs.artifact_name_for_release }}
      release_tag: ${{ steps.prepare_release_outputs.outputs.release_tag_name }}
      release_title: ${{ steps.prepare_release_outputs.outputs.release_title_name }}
      final_kernel_local_version_output: ${{ steps.generate_suffixes.outputs.final_kernel_local_version_for_release_body }}
      current_build_date_formatted_output: ${{ steps.generate_suffixes.outputs.current_build_date_formatted_for_release_body }}
      parsed_kernel_version_output: ${{ steps.parse_kernel.outputs.parsed_kernel_version }}
      parsed_sub_level_output: ${{ steps.parse_kernel.outputs.parsed_sub_level }}
      sukisu_version_from_build_job: ${{ needs.determine_sukisu_version.outputs.sukisu_version }}
      gki_defconfig_path_output: ${{ steps.set_core_paths.outputs.gki_defconfig_path_output }}
      effective_kpm_setting: ${{ steps.kpm_settings.outputs.effective_kpm_value }}
    env:
      CCACHE_COMPILERCHECK: "%compiler% -dumpmachine; %compiler% -dumpversion"
      CCACHE_NOHASHDIR: "true"
      CCACHE_HARDLINK: "true"
      SUKI_VERSION_NUM_FROM_PREVIOUS_JOB: ${{ needs.determine_sukisu_version.outputs.sukisu_version }}
      BAZEL_OPTIMIZATION_FLAGS: >- # Multiline for clarity
        --jobs=$(nproc)
        --local_ram_resources=HOST_RAM*0.8
      CCACHE_LOGFILE: /tmp/ccache.log
      BAZEL_PROFILE_FILENAME: bazel_profile.json
      DEBIAN_FRONTEND: noninteractive # For apt-get

    steps:
      - name: 验证输入参数 (基本)
        run: |
          set -euo pipefail
          kernel_input="${{ github.event.inputs.kernel_to_build }}"
          if [[ -z "$kernel_input" ]]; then
            echo "::error::'kernel_to_build' input is empty."
            exit 1
          fi
          # A more specific regex could be added here if needed, for example:
          # if ! [[ "$kernel_input" =~ ^android[0-9]+_[0-9]+\.[0-9]+(_[0-9]+)?(_[0-9]{4}-[0-9]{2})?(_r[0-9]+)?(_X_lts_)?.*$ ]]; then
          #   echo "::error::'kernel_to_build' input format appears invalid: $kernel_input"
          #   exit 1
          # fi
          echo "Input 'kernel_to_build': $kernel_input - basic validation passed."

      - name: 解析内核参数 # Candidate for script externalization
        id: parse_kernel
        run: |
          set -euo pipefail
          IFS='_' read -r av kv sl opl rev_raw <<< "${{ github.event.inputs.kernel_to_build }}"
          echo "SELECTED_ANDROID_VERSION=$av" >> $GITHUB_ENV
          echo "SELECTED_KERNEL_VERSION=$kv" >> $GITHUB_ENV
          echo "SELECTED_SUB_LEVEL=$sl" >> $GITHUB_ENV
          echo "SELECTED_OS_PATCH_LEVEL=$opl" >> $GITHUB_ENV
          rev="${rev_raw:-}" # Handle potentially empty revision
          echo "SELECTED_REVISION=$rev" >> $GITHUB_ENV
          echo "parsed_kernel_version=$kv" >> $GITHUB_OUTPUT
          echo "parsed_sub_level=$sl" >> $GITHUB_OUTPUT
          echo "Parsed kernel parameters: AV=$av, KV=$kv, SL=$sl, OPL=$opl, REV=$rev"

      - name: 设置核心路径和配置名称
        id: set_core_paths
        run: |
          set -euo pipefail
          CONFIG_DIR_NAME_VALUE="${{ env.SELECTED_ANDROID_VERSION }}-${{ env.SELECTED_KERNEL_VERSION }}-${{ env.SELECTED_SUB_LEVEL }}"
          echo "CONFIG=${CONFIG_DIR_NAME_VALUE}" >> $GITHUB_ENV

          KERNEL_SOURCE_DIRECTORY_VALUE="${GITHUB_WORKSPACE}/${CONFIG_DIR_NAME_VALUE}"
          echo "KERNEL_SRC_ROOT=${KERNEL_SOURCE_DIRECTORY_VALUE}" >> $GITHUB_ENV

          GKI_DEFCONFIG_FILE_PATH_VALUE="${KERNEL_SOURCE_DIRECTORY_VALUE}/common/arch/arm64/configs/gki_defconfig"
          echo "GKI_DEFCONFIG_PATH_ENV=${GKI_DEFCONFIG_FILE_PATH_VALUE}" >> $GITHUB_ENV
          echo "gki_defconfig_path_output=${GKI_DEFCONFIG_FILE_PATH_VALUE}" >> $GITHUB_OUTPUT

          echo "Set CONFIG env var to: ${CONFIG_DIR_NAME_VALUE}"
          echo "Set KERNEL_SRC_ROOT env var to: ${KERNEL_SOURCE_DIRECTORY_VALUE}"
          echo "Set GKI_DEFCONFIG_PATH_ENV env var to: ${GKI_DEFCONFIG_FILE_PATH_VALUE}"
          echo "Output gki_defconfig_path_output: ${GKI_DEFCONFIG_FILE_PATH_VALUE}"

      - name: 生成版本后缀和日期 # Candidate for script externalization
        id: generate_suffixes
        env:
          USER_PROVIDED_SUFFIX: ${{ github.event.inputs.custom_version_suffix }}
          SELECTED_AV_ENV: ${{ env.SELECTED_ANDROID_VERSION }}
          SELECTED_KV_ENV: ${{ env.SELECTED_KERNEL_VERSION }}
        run: |
          set -euo pipefail
          final_kernel_local_version=""
          artifact_name_suffix_part=""
          current_date_yyyymmdd=$(date +%Y%m%d)
          current_date_formatted=$(date +"%Y年%m月%d日")

          if [[ -n "$USER_PROVIDED_SUFFIX" ]]; then
            final_kernel_local_version="$USER_PROVIDED_SUFFIX"
            artifact_name_suffix_part="$USER_PROVIDED_SUFFIX" # Or keep consistent date for custom
            echo "Using user-provided suffix: $final_kernel_local_version"
          else
            kernel_fixed_part_for_localversion=""
            # Simplified conditions for brevity, original logic was more complex
            if [ "$SELECTED_AV_ENV" == "android12" ] && [ "$SELECTED_KV_ENV" == "5.10" ]; then
              kernel_fixed_part_for_localversion="-android12-9"
            elif [ "$SELECTED_AV_ENV" == "android13" ] && [ "$SELECTED_KV_ENV" == "5.10" ]; then
              kernel_fixed_part_for_localversion="-android13-9"
            elif [ "$SELECTED_AV_ENV" == "android13" ] && [ "$SELECTED_KV_ENV" == "5.15" ]; then
              kernel_fixed_part_for_localversion="-android13-8"
            elif [ "$SELECTED_AV_ENV" == "android14" ] && [ "$SELECTED_KV_ENV" == "6.1" ]; then
              kernel_fixed_part_for_localversion="-android14-11"
            elif [ "$SELECTED_AV_ENV" == "android15" ] && [ "$SELECTED_KV_ENV" == "6.6" ]; then
              kernel_fixed_part_for_localversion="-android15-8"
            else
              # Generic fallback, ensure SELECTED_KV_ENV has '.' replaced for safety if used in paths
              kernel_fixed_part_for_localversion="-${SELECTED_AV_ENV}-${SELECTED_KV_ENV//./_}-custom"
            fi

            prefix1="gd"
            prefix2="ab"
            # Ensure random parts are generated safely
            random_hex_11=$(head /dev/urandom | LC_ALL=C tr -dc 'a-f0-9' | head -c 11 || echo "randhexerr")
            random_digits_8=$(head /dev/urandom | LC_ALL=C tr -dc '0-9' | head -c 8 || echo "randdigerr")

            final_kernel_local_version="${kernel_fixed_part_for_localversion}-${prefix1}${random_hex_11}-${prefix2}${random_digits_8}"
            artifact_name_suffix_part="-${current_date_yyyymmdd}" # Consistent date suffix for non-custom
            echo "Generated pseudo-official suffix: $final_kernel_local_version"
          fi

          echo "FINAL_KERNEL_LOCAL_VERSION=${final_kernel_local_version}" >> "$GITHUB_ENV"
          echo "ARTIFACT_NAME_SUFFIX_PART=${artifact_name_suffix_part}" >> "$GITHUB_ENV"
          echo "final_kernel_local_version_for_release_body=${final_kernel_local_version}" >> $GITHUB_OUTPUT
          echo "current_build_date_formatted_for_release_body=${current_date_formatted}" >> $GITHUB_OUTPUT
          echo "Version suffixes generated. LOCALVERSION: $final_kernel_local_version, Artifact Suffix: $artifact_name_suffix_part, Date: $current_date_formatted"

      - name: 调整KPM设置
        id: kpm_settings
        run: |
          set -euo pipefail
          EFFECTIVE_KPM_VALUE=""
          if [[ "${{ env.SELECTED_ANDROID_VERSION }}" == "android15" && "${{ env.SELECTED_KERNEL_VERSION }}" == "6.6" ]]; then
            EFFECTIVE_KPM_VALUE="false"
            echo "KPM is forced to 'false' for Android 15 with Kernel 6.6."
          else
            EFFECTIVE_KPM_VALUE="${{ github.event.inputs.use_kpm }}"
            echo "KPM setting based on user input: $EFFECTIVE_KPM_VALUE"
          fi
          echo "EFFECTIVE_USE_KPM=${EFFECTIVE_KPM_VALUE}" >> $GITHUB_ENV
          echo "effective_kpm_value=${EFFECTIVE_KPM_VALUE}" >> $GITHUB_OUTPUT

      - name: 优化构建空间
        uses: easimon/maximize-build-space@master # Consider pinning to a specific commit/tag
        with:
          root-reserve-mb: 8192
          temp-reserve-mb: 2048
          swap-size-mb: 8192
          remove-dotnet: "true"
          remove-android: "true"
          remove-haskell: "true"
          remove-codeql: "true"

      - name: 安装ccache及依赖
        run: |
          set -euo pipefail
          sudo apt-get update -qq
          sudo apt-get install -yq --no-install-recommends ccache python3 git curl time libssl-dev flex

      - name: 配置ccache
        run: |
          set -euo pipefail
          mkdir -p ~/.cache/bazel # Bazel cache dir for user
          echo "当前ccache版本信息:"
          ccache --version
          ccache --max-size=2G
          ccache --set-config=compression=true
          if ccache --version | grep -q 'Zstd'; then
            echo "检测到ccache支持Zstd。设置 compression_type 为 zstd。"
            ccache --set-config=compression_type=zstd
          else
            echo "未检测到ccache支持Zstd。将使用默认的压缩类型 (通常是zlib)。"
          fi
          echo "CCACHE_DIR=$HOME/.ccache" >> $GITHUB_ENV # Ensure this is set if not already default
          echo "当前ccache配置统计信息:"
          ccache -s
          echo "ccache configuration complete."

      - name: 还原ccache缓存
        uses: actions/cache@v4
        with:
          path: ~/.ccache
          key: ${{ runner.os }}-ccache-v2-${{ github.event.inputs.kernel_to_build }}-${{ hashFiles('.github/workflows/**.yml') }}
          restore-keys: |
            ${{ runner.os }}-ccache-v2-${{ github.event.inputs.kernel_to_build }}-
            ${{ runner.os }}-ccache-v2-

      - name: 缓存预编译工具链
        id: cache-toolchain
        uses: actions/cache@v4
        with:
          path: |
            kernel-build-tools
            mkbootimg
          key: toolchain-${{ runner.os }}-v3 # Incremented version for any changes in download logic

      - name: 下载预编译工具链 (若缓存未命中)
        if: steps.cache-toolchain.outputs.cache-hit != 'true'
        run: |
          set -euo pipefail
          AOSP_MIRROR=https://android.googlesource.com
          BUILD_TOOLS_BRANCH=main-kernel-build-2024 # Pin or make configurable if needed
          MKBOOTIMG_BRANCH=main # Pin or make configurable if needed
          echo "Cache miss for toolchain. Downloading prebuilt tools..."
          git clone "$AOSP_MIRROR/kernel/prebuilts/build-tools" -b "$BUILD_TOOLS_BRANCH" --depth 1 kernel-build-tools
          git clone "$AOSP_MIRROR/platform/system/tools/mkbootimg" -b "$MKBOOTIMG_BRANCH" --depth 1 mkbootimg
          echo "Toolchain download complete."

      - name: 设置工具链环境变量
        run: |
          set -euo pipefail
          echo "AVBTOOL=$GITHUB_WORKSPACE/kernel-build-tools/linux-x86/bin/avbtool" >> $GITHUB_ENV
          echo "MKBOOTIMG=$GITHUB_WORKSPACE/mkbootimg/mkbootimg.py" >> $GITHUB_ENV
          echo "UNPACK_BOOTIMG=$GITHUB_WORKSPACE/mkbootimg/unpack_bootimg.py" >> $GITHUB_ENV
          echo "Toolchain environment variables set."

      - name: 设置签名密钥
        env:
          BOOT_SIGN_KEY: ${{ secrets.BOOT_SIGN_KEY }}
        run: |
          set -euo pipefail
          KEY_DIR="$GITHUB_WORKSPACE/kernel-build-tools/linux-x86/share/avb"
          mkdir -p "$KEY_DIR"
          if [ -z "$BOOT_SIGN_KEY" ]; then
            echo "BOOT_SIGN_KEY secret is not set. Generating a test key."
            openssl genpkey -algorithm RSA -pkeyopt rsa_keygen_bits:2048 > "$KEY_DIR/testkey_rsa2048.pem"
            echo "BOOT_SIGN_KEY_PATH=$KEY_DIR/testkey_rsa2048.pem" >> $GITHUB_ENV
            echo "Test signing key generated."
          else
            echo "Using BOOT_SIGN_KEY from secrets."
            echo "$BOOT_SIGN_KEY" > "$KEY_DIR/production_key.pem"
            echo "BOOT_SIGN_KEY_PATH=$KEY_DIR/production_key.pem" >> $GITHUB_ENV
            echo "Production signing key configured."
          fi

      - name: 安装repo工具
        run: |
          set -euo pipefail
          mkdir -p ./git-repo
          curl -sS https://storage.googleapis.com/git-repo-downloads/repo > ./git-repo/repo
          chmod a+rx ./git-repo/repo
          echo "REPO=$GITHUB_WORKSPACE/./git-repo/repo" >> $GITHUB_ENV
          echo "Repo tool installed."

      - name: 检查依赖项安全 (可选)
        uses: actions/dependency-review-action@v4
        with:
          base-ref: ${{ github.sha }}~1 # Be cautious with this if force pushes occur
          head-ref: ${{ github.sha }}
          fail-on-severity: high
          allow-licenses: MIT, Apache-2.0, GPL-2.0, BSD-3-Clause
          continue-on-error: true # Workflow continues even if issues are found

      - name: 克隆依赖仓库 (AnyKernel3等)
        run: |
          set -euo pipefail
          ANYKERNEL_BRANCH="gki-2.0" # Pin or make configurable
          SUSFS_BRANCH_SPECIFIC="gki-${{ env.SELECTED_ANDROID_VERSION }}-${{ env.SELECTED_KERNEL_VERSION }}"
          SUSFS_BRANCH_FALLBACK="main" # Pin or make configurable

          echo "Cloning AnyKernel3 (branch: $ANYKERNEL_BRANCH)..."
          git clone https://github.com/WildPlusKernel/AnyKernel3.git -b "$ANYKERNEL_BRANCH" AnyKernel3

          echo "Attempting to clone susfs4ksu with branch: $SUSFS_BRANCH_SPECIFIC..."
          if ! git clone https://gitlab.com/simonpunk/susfs4ksu.git -b "$SUSFS_BRANCH_SPECIFIC" susfs4ksu; then
            echo "Failed to clone susfs4ksu with branch $SUSFS_BRANCH_SPECIFIC, trying fallback branch $SUSFS_BRANCH_FALLBACK..."
            git clone https://gitlab.com/simonpunk/susfs4ksu.git -b "$SUSFS_BRANCH_FALLBACK" susfs4ksu
          fi
          echo "Cloned susfs4ksu successfully."

          echo "Cloning kernel_patches..."
          git clone https://github.com/WildPlusKernel/kernel_patches.git kernel_patches # Pin or make configurable

          echo "Cloning SukiSU_patch..."
          git clone https://github.com/ShirkNeko/SukiSU_patch.git SukiSU_patch # Pin or make configurable
          echo "Dependency repositories cloned."

      - name: 同步内核源码 (带重试) # Candidate for script externalization
        uses: nick-fields/retry@v3
        with:
          timeout_minutes: 20
          max_attempts: 3
          command: |
            set -euo pipefail # Important for the script block
            mkdir -p "${{ env.KERNEL_SRC_ROOT }}"
            cd "${{ env.KERNEL_SRC_ROOT }}"

            _MANIFEST_BRANCH_BASE="common-${{ env.SELECTED_ANDROID_VERSION }}-${{ env.SELECTED_KERNEL_VERSION }}"
            _MANIFEST_BRANCH=""

            if [[ -n "${{ env.SELECTED_OS_PATCH_LEVEL }}" && "${{ env.SELECTED_OS_PATCH_LEVEL }}" != "X" ]]; then
              _MANIFEST_BRANCH="${_MANIFEST_BRANCH_BASE}-${{ env.SELECTED_OS_PATCH_LEVEL }}"
            elif [[ "${{ github.event.inputs.kernel_to_build }}" == *"_X_lts_"* || "${{ github.event.inputs.kernel_to_build }}" == *"_lts_"* ]]; then
              _MANIFEST_BRANCH="${_MANIFEST_BRANCH_BASE}-lts"
            else
              _MANIFEST_BRANCH="${_MANIFEST_BRANCH_BASE}"
            fi

            echo "Using manifest branch: $_MANIFEST_BRANCH for repo init"
            # Using --repo-rev to pin repo tool version for stability
            ${{ env.REPO }} init --depth=1 -u https://android.googlesource.com/kernel/manifest -b $_MANIFEST_BRANCH --repo-rev=v2.16

            DEFAULT_MANIFEST_PATH=".repo/manifests/default.xml"
            if [ ! -f "$DEFAULT_MANIFEST_PATH" ] && [ -f .repo/manifest.xml ]; then
              DEFAULT_MANIFEST_PATH=.repo/manifest.xml # Fallback for older repo versions
            fi

            # Check for deprecated common branch and adjust manifest
            # This logic is complex and relies on specific manifest structure
            COMMON_PROJECT_REVISION_IN_MANIFEST=$(grep 'project path="common"' "$DEFAULT_MANIFEST_PATH" | sed -n 's/.*revision="\([^"]*\)".*/\1/p' | head -n 1)
            if [ -z "$COMMON_PROJECT_REVISION_IN_MANIFEST" ]; then
                COMMON_PROJECT_REVISION_IN_MANIFEST=$(grep 'project path="kernel/common"' "$DEFAULT_MANIFEST_PATH" | sed -n 's/.*revision="\([^"]*\)".*/\1/p' | head -n 1)
                if [ -z "$COMMON_PROJECT_REVISION_IN_MANIFEST" ]; then
                  COMMON_PROJECT_REVISION_IN_MANIFEST=$_MANIFEST_BRANCH # Fallback if not found
                fi
            fi

            REMOTE_COMMON_BRANCH_STATUS=$(git ls-remote https://android.googlesource.com/kernel/common "$COMMON_PROJECT_REVISION_IN_MANIFEST")
            if echo "$REMOTE_COMMON_BRANCH_STATUS" | grep -q "refs/heads/deprecated/$COMMON_PROJECT_REVISION_IN_MANIFEST"; then
              echo "Common kernel branch '$COMMON_PROJECT_REVISION_IN_MANIFEST' is deprecated. Adjusting manifest for 'deprecated/' prefix."
              # Use a temporary file for sed -i portability if needed, though GitHub runners are usually GNU sed
              sed -i "/project path=\"common\"/s|revision=\"$COMMON_PROJECT_REVISION_IN_MANIFEST\"|revision=\"deprecated/$COMMON_PROJECT_REVISION_IN_MANIFEST\"|" "$DEFAULT_MANIFEST_PATH" || \
              sed -i "/project path=\"kernel\/common\"/s|revision=\"$COMMON_PROJECT_REVISION_IN_MANIFEST\"|revision=\"deprecated/$COMMON_PROJECT_REVISION_IN_MANIFEST\"|" "$DEFAULT_MANIFEST_PATH"
              echo "Manifest potentially updated to use deprecated/ branch for common project."
            fi

            echo "Syncing kernel sources..."
            ${{ env.REPO }} --trace sync -c -j$(nproc --all) --no-tags --fail-fast --current-branch
            echo "Kernel source sync complete."

      - name: 设置SukiSU分支参数
        run: |
          set -euo pipefail
          KSU_SETUP_BRANCH_ARG=""
          if [[ "${{ github.event.inputs.kernelsu_branch }}" == "Stable" ]]; then
            KSU_SETUP_BRANCH_ARG="" # No argument means stable
            echo "SukiSU branch: Stable (default)"
          elif [[ "${{ github.event.inputs.kernelsu_branch }}" == "Dev" ]]; then
            KSU_SETUP_BRANCH_ARG="-s susfs-dev"
            echo "SukiSU branch: Dev (using susfs-dev)"
          elif [[ "${{ github.event.inputs.kernelsu_branch }}" == "Other" ]]; then
            KSU_SETUP_BRANCH_ARG="" # User might provide their own or use default
            echo "SukiSU branch: Other (default setup or custom)"
          fi
          echo "KSU_BRANCH_ARG=${KSU_SETUP_BRANCH_ARG}" >> $GITHUB_ENV

      - name: 集成SukiSU
        run: |
          set -euo pipefail
          cd "${{ env.KERNEL_SRC_ROOT }}"
          echo "Integrating SukiSU using setup.sh with args: ${{ env.KSU_BRANCH_ARG }}"
          # Using curl | bash is a common pattern but carries risks if the source script is compromised.
          # Consider cloning the SukiSU-Ultra repo and running setup.sh from the local clone for more security.
          curl -LSs "https://raw.githubusercontent.com/ShirkNeko/SukiSU-Ultra/main/kernel/setup.sh" | bash -s -- ${{ env.KSU_BRANCH_ARG }}
          echo "SukiSU integration script executed."

      - name: 设置SukiSU版本号
        shell: bash
        run: |
          set -euo pipefail
          final_suki_version_num_for_env="${{ needs.determine_sukisu_version.outputs.sukisu_version }}"
          if [[ "$final_suki_version_num_for_env" =~ ^[0-9]+$ ]]; then
            echo "SUKI_VERSION_NUM=$final_suki_version_num_for_env" >> $GITHUB_ENV
            echo "SukiSU version number set to: $final_suki_version_num_for_env"
          else
            echo "SUKI_VERSION_NUM=NoVer" >> $GITHUB_ENV # Fallback value
            echo "::warning::Invalid SukiSU version from previous job ('$final_suki_version_num_for_env'). Using 'NoVer'."
          fi

      - name: 应用SUSFS补丁 (旧版逻辑) # Candidate for script externalization
        working-directory: ${{ env.KERNEL_SRC_ROOT }}
        shell: bash
        run: |
          set -euo pipefail
          echo "Applying SUSFS patches using old workflow logic..."
          mkdir -p ./common/fs
          mkdir -p ./common/include/linux

          SUSFS_PATCH_SRC_FILE_PATH="${GITHUB_WORKSPACE}/susfs4ksu/kernel_patches/50_add_susfs_in_gki-${{ env.SELECTED_ANDROID_VERSION }}-${{ env.SELECTED_KERNEL_VERSION }}.patch"
          SUSFS_PATCH_DEST_DIR_PATH="./common/"

          if [ -f "$SUSFS_PATCH_SRC_FILE_PATH" ]; then
            echo "Copying SUSFS patch from $SUSFS_PATCH_SRC_FILE_PATH to $SUSFS_PATCH_DEST_DIR_PATH"
            cp "$SUSFS_PATCH_SRC_FILE_PATH" "$SUSFS_PATCH_DEST_DIR_PATH"
          else
            echo "::warning::SUSFS source patch file not found at $SUSFS_PATCH_SRC_FILE_PATH (old logic). This may be expected."
          fi

          SUSFS_FS_SRC_PATH="${GITHUB_WORKSPACE}/susfs4ksu/kernel_patches/fs"
          SUSFS_FS_DEST_PATH="./common/fs/"
          if [ -d "$SUSFS_FS_SRC_PATH" ] && [ -n "$(ls -A $SUSFS_FS_SRC_PATH)" ]; then
            echo "Copying SUSFS fs directory contents from $SUSFS_FS_SRC_PATH to $SUSFS_FS_DEST_PATH"
            cp -r ${SUSFS_FS_SRC_PATH}/* "$SUSFS_FS_DEST_PATH"
          elif [ -d "$SUSFS_FS_SRC_PATH" ]; then
             echo "SUSFS source fs directory is empty: $SUSFS_FS_SRC_PATH"
          else
            echo "::warning::SUSFS source fs directory not found: $SUSFS_FS_SRC_PATH (old logic)."
          fi

          SUSFS_INCLUDE_SRC_PATH="${GITHUB_WORKSPACE}/susfs4ksu/kernel_patches/include/linux"
          SUSFS_INCLUDE_DEST_PATH="./common/include/linux/"
          if [ -d "$SUSFS_INCLUDE_SRC_PATH" ] && [ -n "$(ls -A $SUSFS_INCLUDE_SRC_PATH)" ]; then
            echo "Copying SUSFS include/linux contents from $SUSFS_INCLUDE_SRC_PATH to $SUSFS_INCLUDE_DEST_PATH"
            cp -r ${SUSFS_INCLUDE_SRC_PATH}/* "$SUSFS_INCLUDE_DEST_PATH"
          elif [ -d "$SUSFS_INCLUDE_SRC_PATH" ]; then
            echo "SUSFS source include/linux directory is empty: $SUSFS_INCLUDE_SRC_PATH"
          else
            echo "::warning::SUSFS source include/linux directory not found: $SUSFS_INCLUDE_SRC_PATH (old logic)."
          fi

          cd ./common

          SUSFS_PATCH_FILENAME_IN_COMMON="50_add_susfs_in_gki-${{ env.SELECTED_ANDROID_VERSION }}-${{ env.SELECTED_KERNEL_VERSION }}.patch"
          if [ -f "./${SUSFS_PATCH_FILENAME_IN_COMMON}" ]; then
            echo "Attempting to apply patch: ./${SUSFS_PATCH_FILENAME_IN_COMMON}"
            # This patch application is explicitly allowed to fail or apply with fuzz without stopping the build.
            patch -p1 --fuzz=3 < "./${SUSFS_PATCH_FILENAME_IN_COMMON}" || true
            echo "SUSFS patch application attempted (old logic). Check logs for actual success/failure."
          else
            echo "::warning::SUSFS patch file ./${SUSFS_PATCH_FILENAME_IN_COMMON} not found in ./common/ (old logic). This may be intended."
          fi

          FORMATTED_BRANCH_FOR_FIX_COMPARE="${{ env.SELECTED_ANDROID_VERSION }}-${{ env.SELECTED_KERNEL_VERSION }}-${{ env.SELECTED_OS_PATCH_LEVEL }}"
          # Check specific conditions for fix patch
          if [[ "$FORMATTED_BRANCH_FOR_FIX_COMPARE" == "android15-6.6-2024-08" || "$FORMATTED_BRANCH_FOR_FIX_COMPARE" == "android15-6.6-2024-09" ]]; then # Example condition
            echo "Applying fix for 6.6 kernel (android15-6.6 specific patch level) using old logic..."
            curl -LSs https://github.com/zzh20188/GKI_KernelSU_SUSFS/raw/refs/heads/fix/fix6.6.patch -o fix6.6.patch
            patch -p1 < fix6.6.patch || true # Also allowed to fail or fuzz
            echo "Fix patch for 6.6 attempted (old logic)."
          fi
          echo "SUSFS patching (old logic) finished."

      - name: 并行应用内核补丁 (不含SUSFS) # Candidate for script externalization
        shell: bash
        run: |
          set -euo pipefail
          echo "Starting parallel patch application (SUSFS handled separately)..."
          COMMON_DIR_PATH="${{ env.KERNEL_SRC_ROOT }}/common"

          apply_hooks_patch() {
            echo "Applying SukiSU hooks patch..."
            cd "$COMMON_DIR_PATH" || exit 1
            HOOKS_PATCH_FILE="${GITHUB_WORKSPACE}/SukiSU_patch/hooks/syscall_hooks.patch"
            if [ -f "$HOOKS_PATCH_FILE" ]; then
              cp "$HOOKS_PATCH_FILE" ./syscall_hooks.patch
              patch -p1 -F 3 < syscall_hooks.patch || { echo "::error::SukiSU hooks patch failed or applied with too much fuzz."; exit 1; }
            else
              echo "::error::SukiSU hooks patch file not found: $HOOKS_PATCH_FILE"; exit 1;
            fi
            echo "SukiSU hooks patch process finished."
          }

          apply_zram_compression_patches() {
            if [[ "${{ github.event.inputs.use_zram }}" == "true" ]]; then
              echo "Applying additional ZRAM compression patches..."
              cd "$COMMON_DIR_PATH" || exit 1
              ZRAM_PATCH_BASE="${GITHUB_WORKSPACE}/SukiSU_patch/other/zram"

              # Copy directories if they exist and are not empty
              for comp_dir in lz4k/include/linux lz4k/lib lz4k/crypto; do
                  src_path="${ZRAM_PATCH_BASE}/${comp_dir}"
                  dest_path="./${comp_dir%/*}" # e.g. ./include/linux for lz4k/include/linux
                  if [ -d "$src_path" ]; then
                      mkdir -p "$dest_path"
                      # Ensure source is not empty before copy
                      if [ -n "$(ls -A "$src_path")" ]; then
                          cp -r "${src_path}/." "$dest_path/" || { echo "::error::Copy failed for $src_path"; exit 1; }
                      else
                          echo "::warning::Source directory $src_path is empty."
                      fi
                  else
                      echo "::warning::Source directory $src_path not found."
                  fi
              done
              if [ -d "${ZRAM_PATCH_BASE}/lz4k_oplus" ]; then
                mkdir -p ./lib
                cp -r "${ZRAM_PATCH_BASE}/lz4k_oplus" ./lib/ || { echo "::error::lz4k_oplus copy to lib failed"; exit 1; }
              fi


              LZ4KD_PATCH_PATH="${ZRAM_PATCH_BASE}/zram_patch/${{ env.SELECTED_KERNEL_VERSION }}/lz4kd.patch"
              if [ -f "$LZ4KD_PATCH_PATH" ]; then
                cp "$LZ4KD_PATCH_PATH" ./lz4kd.patch
                patch -p1 -F 3 < lz4kd.patch || { echo "::error::lz4kd patch failed for ${{ env.SELECTED_KERNEL_VERSION }}"; exit 1; }
              else
                echo "::warning::lz4kd patch not found for ${{ env.SELECTED_KERNEL_VERSION }} at $LZ4KD_PATCH_PATH"
              fi

              LZ4K_OPLUS_PATCH_PATH="${ZRAM_PATCH_BASE}/zram_patch/${{ env.SELECTED_KERNEL_VERSION }}/lz4k_oplus.patch"
              if [ -f "$LZ4K_OPLUS_PATCH_PATH" ]; then
                cp "$LZ4K_OPLUS_PATCH_PATH" ./lz4k_oplus.patch
                patch -p1 -F 3 < lz4k_oplus.patch || { echo "::error::lz4k_oplus patch failed for ${{ env.SELECTED_KERNEL_VERSION }}"; exit 1; }
              else
                echo "::warning::lz4k_oplus patch not found for ${{ env.SELECTED_KERNEL_VERSION }} at $LZ4K_OPLUS_PATCH_PATH"
              fi
              echo "ZRAM compression patches process finished."
            else
              echo "Skipping ZRAM compression patches as use_zram is false."
            fi
          }

          apply_hide_stuff_patch() {
            echo "Applying hide stuff patch..."
            cd "$COMMON_DIR_PATH" || exit 1
            HIDE_PATCH_FILE="${GITHUB_WORKSPACE}/SukiSU_patch/69_hide_stuff.patch"
            if [ -f "$HIDE_PATCH_FILE" ]; then
              cp "$HIDE_PATCH_FILE" ./hide_stuff.patch
              patch -p1 -F 3 < hide_stuff.patch || { echo "::error::Hide stuff patch failed."; exit 1; }
            else
              echo "::error::Hide stuff patch file not found: $HIDE_PATCH_FILE"; exit 1;
            fi
            echo "Hide stuff patch process finished."
          }

          apply_hooks_patch &
          PID_HOOKS=$!
          apply_zram_compression_patches &
          PID_ZRAM=$!
          apply_hide_stuff_patch &
          PID_HIDE=$!

          echo "Waiting for non-SUSFS patch processes to complete..."
          FAIL=0
          wait $PID_HOOKS || { echo "::error::Hooks patching failed in background (PID $PID_HOOKS)."; FAIL=1; }
          wait $PID_ZRAM || { echo "::error::ZRAM patching failed in background (PID $PID_ZRAM)."; FAIL=1; }
          wait $PID_HIDE || { echo "::error::Hide stuff patching failed in background (PID $PID_HIDE)."; FAIL=1; }

          if [ "$FAIL" -eq 1 ]; then
            echo "::error::One or more non-SUSFS patch processes critically failed. Check logs."
            exit 1 # Exit if any background patch job failed
          else
            echo "All non-SUSFS patch processes completed successfully."
          fi

      - name: 配置ZRAM算法 # Candidate for script externalization
        if: ${{ github.event.inputs.use_zram == 'true' }}
        run: |
          set -euo pipefail
          CONFIG_FILE_PATH="${{ env.GKI_DEFCONFIG_PATH_ENV }}"
          echo "Configuring ZRAM algorithms in $CONFIG_FILE_PATH"

          if [ ! -f "$CONFIG_FILE_PATH" ]; then
            echo "::error::gki_defconfig not found at $CONFIG_FILE_PATH for ZRAM config"
            exit 1
          fi

          # Ensure options are 'y' if present, add if not.
          # This is a common pattern to update defconfig files.
          update_config() {
            local key="$1"
            local value="$2"
            if grep -q "^${key}=" "$CONFIG_FILE_PATH"; then
              sed -i "s|^${key}=.*|${key}=${value}|" "$CONFIG_FILE_PATH"
            else
              echo "${key}=${value}" >> "$CONFIG_FILE_PATH"
            fi
            # Remove commented out version if it exists
            sed -i "/^# ${key} is not set/d" "$CONFIG_FILE_PATH"
          }

          update_config "CONFIG_ZSMALLOC" "y"
          update_config "CONFIG_ZRAM" "y"

          if [ "${{ env.SELECTED_KERNEL_VERSION }}" = "5.10" ]; then
            update_config "CONFIG_MODULE_SIG" "n" # Original had sed and echo, this is cleaner
            update_config "CONFIG_CRYPTO_LZO" "y"
            update_config "CONFIG_ZRAM_DEF_COMP_LZ4KD" "y"
          fi

          if [ "${{ env.SELECTED_ANDROID_VERSION }}" = "android14" ] || [ "${{ env.SELECTED_ANDROID_VERSION }}" = "android15" ]; then
            MODULES_BZL_PATH="${{ env.KERNEL_SRC_ROOT }}/common/modules.bzl"
            if [ -f "$MODULES_BZL_PATH" ]; then
              # Remove specific modules if they are to be built-in
              sed -i 's/"drivers\/block\/zram\/zram\.ko",//g; s/"mm\/zsmalloc\.ko",//g' "$MODULES_BZL_PATH"
              echo "Attempted to remove zram.ko and zsmalloc.ko from $MODULES_BZL_PATH for A14/A15."
            fi
            update_config "CONFIG_MODULE_SIG_FORCE" "n"
          elif [ "${{ env.SELECTED_KERNEL_VERSION }}" = "5.10" ] || [ "${{ env.SELECTED_KERNEL_VERSION }}" = "5.15" ]; then
            GKI_MODULES_FILE="${{ env.KERNEL_SRC_ROOT }}/common/android/gki_aarch64_modules"
            if [ -f "$GKI_MODULES_FILE" ]; then
                echo -n > "$GKI_MODULES_FILE" # Clear the file
                echo "Cleared $GKI_MODULES_FILE for older kernels with built-in ZRAM."
            fi
          fi

          # Add these only if ZRAM and ZSMALLOC are enabled
          if grep -q "^CONFIG_ZSMALLOC=y$" "$CONFIG_FILE_PATH" && grep -q "^CONFIG_ZRAM=y$" "$CONFIG_FILE_PATH"; then
            update_config "CONFIG_CRYPTO_LZ4HC" "y"
            update_config "CONFIG_CRYPTO_LZ4K" "y"
            update_config "CONFIG_CRYPTO_LZ4KD" "y"
            update_config "CONFIG_CRYPTO_842" "y"
            update_config "CONFIG_CRYPTO_LZ4K_OPLUS" "y"
            echo "Added various ZRAM-related crypto configs."
          fi

          sort -u "$CONFIG_FILE_PATH" -o "$CONFIG_FILE_PATH" # Keep it sorted and unique
          echo "ZRAM algorithm configuration finished."

      - name: 配置SUSFS及附加功能 # Candidate for script externalization
        run: |
          set -euo pipefail
          GKI_DEFCONFIG_PATH="${{ env.GKI_DEFCONFIG_PATH_ENV }}"
          BUILD_CONFIG_GKI_PATH="${{ env.KERNEL_SRC_ROOT }}/common/build.config.gki"
          BUILD_CONFIG_BAZEL_PATH="${{ env.KERNEL_SRC_ROOT }}/common/build.config.gki.aarch64" # Might not exist on all branches
          BUILD_CONFIG_GENERIC_PATH="${{ env.KERNEL_SRC_ROOT }}/common/build.config" # Generic, might not exist

          echo "Configuring SUSFS and additional features in $GKI_DEFCONFIG_PATH"
          if [ ! -f "$GKI_DEFCONFIG_PATH" ]; then
            echo "::error::gki_defconfig not found at $GKI_DEFCONFIG_PATH for SUSFS config"
            exit 1
          fi

          # Helper to update defconfig
          update_defconfig() {
            local key="$1"
            local value="$2"
            # Remove existing line (commented or not)
            sed -i -e "/^${key}=/d" -e "/^# ${key} is not set/d" "$GKI_DEFCONFIG_PATH"
            # Add new line
            echo "${key}=${value}" >> "$GKI_DEFCONFIG_PATH"
          }

          configs_to_set_y=(
            "CONFIG_KSU" "CONFIG_KSU_MANUAL_HOOK"
            "CONFIG_TMPFS_XATTR" "CONFIG_TMPFS_POSIX_ACL"
            "CONFIG_IP_NF_TARGET_TTL" "CONFIG_IP6_NF_TARGET_HL" "CONFIG_IP6_NF_MATCH_HL"
            "CONFIG_TCP_CONG_ADVANCED" "CONFIG_TCP_CONG_BBR" "CONFIG_NET_SCH_FQ"
            "CONFIG_KSU_SUSFS" "CONFIG_KSU_SUSFS_HAS_MAGIC_MOUNT" "CONFIG_KSU_SUSFS_SUS_PATH"
            "CONFIG_KSU_SUSFS_SUS_MOUNT" "CONFIG_KSU_SUSFS_AUTO_ADD_SUS_KSU_DEFAULT_MOUNT"
            "CONFIG_KSU_SUSFS_AUTO_ADD_SUS_BIND_MOUNT" "CONFIG_KSU_SUSFS_SUS_KSTAT"
            "CONFIG_KSU_SUSFS_TRY_UMOUNT"
            "CONFIG_KSU_SUSFS_AUTO_ADD_TRY_UMOUNT_FOR_BIND_MOUNT" "CONFIG_KSU_SUSFS_SPOOF_UNAME"
            "CONFIG_KSU_SUSFS_ENABLE_LOG" "CONFIG_KSU_SUSFS_HIDE_KSU_SUSFS_SYMBOLS"
            "CONFIG_KSU_SUSFS_SPOOF_CMDLINE_OR_BOOTCONFIG" "CONFIG_KSU_SUSFS_OPEN_REDIRECT"
          )
          configs_to_set_n=(
            "CONFIG_KSU_SUSFS_SUS_SU" "CONFIG_KSU_SUSFS_SUS_OVERLAYFS"
            "CONFIG_TCP_CONG_BIC" "CONFIG_TCP_CONG_WESTWOOD" "CONFIG_TCP_CONG_HTCP"
          )

          for config_key in "${configs_to_set_y[@]}"; do
            update_defconfig "$config_key" "y"
          done
          for config_key in "${configs_to_set_n[@]}"; do
            update_defconfig "$config_key" "n"
          done

          if [[ "${{ env.EFFECTIVE_USE_KPM }}" == "true" ]]; then
            update_defconfig "CONFIG_KPM" "y"
          else
            update_defconfig "CONFIG_KPM" "n"
          fi

          sort -u "$GKI_DEFCONFIG_PATH" -o "$GKI_DEFCONFIG_PATH"

          build_config_files=("$BUILD_CONFIG_GKI_PATH" "$BUILD_CONFIG_BAZEL_PATH" "$BUILD_CONFIG_GENERIC_PATH")
          for file_path in "${build_config_files[@]}"; do
            if [ -f "$file_path" ]; then
              sed -i 's/check_defconfig//g' "$file_path" # Remove if present
              echo "Attempted to remove 'check_defconfig' from $file_path."
            fi
          done
          echo "SUSFS and additional features configuration finished."

      - name: 配置内核版本参数 # Candidate for script externalization
        working-directory: ${{ env.KERNEL_SRC_ROOT }}
        run: |
          set -euo pipefail
          GKI_DEFCONFIG_FILE_PATH_ACTUAL="${{ env.GKI_DEFCONFIG_PATH_ENV }}"
          SETLOCALVERSION_SCRIPT="./common/scripts/setlocalversion"

          echo "Configuring kernel version parameters..."
          if [ -f "$GKI_DEFCONFIG_FILE_PATH_ACTUAL" ]; then
            # Ensure CONFIG_LOCALVERSION is empty and CONFIG_LOCALVERSION_AUTO is not set
            sed -i '/^CONFIG_LOCALVERSION=/d' "$GKI_DEFCONFIG_FILE_PATH_ACTUAL"
            echo 'CONFIG_LOCALVERSION=""' >> "$GKI_DEFCONFIG_FILE_PATH_ACTUAL"
            sed -i '/^CONFIG_LOCALVERSION_AUTO=/d' "$GKI_DEFCONFIG_FILE_PATH_ACTUAL"
            echo '# CONFIG_LOCALVERSION_AUTO is not set' >> "$GKI_DEFCONFIG_FILE_PATH_ACTUAL" # Comment it out
            sort -u "$GKI_DEFCONFIG_FILE_PATH_ACTUAL" -o "$GKI_DEFCONFIG_FILE_PATH_ACTUAL"
            echo "Cleared CONFIG_LOCALVERSION and disabled CONFIG_LOCALVERSION_AUTO in gki_defconfig."
          else
            echo "::warning::gki_defconfig not found at $GKI_DEFCONFIG_FILE_PATH_ACTUAL for version param config."
          fi

          if [ -f "$SETLOCALVERSION_SCRIPT" ]; then
            if [[ -n "${{ env.FINAL_KERNEL_LOCAL_VERSION }}" ]]; then
              # Override setlocalversion to output the custom version
              echo '#!/bin/sh' > "$SETLOCALVERSION_SCRIPT"
              echo 'echo "${{ env.FINAL_KERNEL_LOCAL_VERSION }}"' >> "$SETLOCALVERSION_SCRIPT"
              chmod +x "$SETLOCALVERSION_SCRIPT"
              echo "Set setlocalversion script to output: ${{ env.FINAL_KERNEL_LOCAL_VERSION }}"
            else
              # If no custom version, ensure '-dirty' is removed from the original script
              sed -i 's/-dirty//g' "$SETLOCALVERSION_SCRIPT"
              echo "Ensured '-dirty' is removed from setlocalversion script (no FINAL_KERNEL_LOCAL_VERSION)."
            fi
          else
            echo "::warning::setlocalversion script not found at $SETLOCALVERSION_SCRIPT."
          fi

          # Bazel-specific tweaks if build.sh is not found (indicating a likely Bazel build)
          BUILD_SCRIPT_PATH_CHECK="./build/build.sh"
          if [ ! -f "$BUILD_SCRIPT_PATH_CHECK" ]; then
            COMMON_BAZEL_PATH_CHECK="./common/BUILD.bazel"
            KLEAF_STAMP_BZL_PATH_CHECK="./build/kernel/kleaf/impl/stamp.bzl" # Path might vary

            if [ -f "$COMMON_BAZEL_PATH_CHECK" ]; then
              # This sed command is very specific and might break if BUILD.bazel format changes
              sed -i '/^[[:space:]]*"protected_exports_list"[[:space:]]*:[[:space:]]*"android\/abi_gki_protected_exports_aarch64",$/d' "$COMMON_BAZEL_PATH_CHECK"
              echo "Attempted to remove protected_exports_list from $COMMON_BAZEL_PATH_CHECK for Bazel build."
            fi
            # Delete ABI dump files that might cause issues
            find ./common/android/ -name "abi_gki_protected_exports_*" -delete
            echo "Removed abi_gki_protected_exports files from ./common/android/ for Bazel build."

            if [ -f "$KLEAF_STAMP_BZL_PATH_CHECK" ]; then
              sed -i "/stable_scmversion_cmd/s/-maybe-dirty//g" "$KLEAF_STAMP_BZL_PATH_CHECK"
              echo "Removed '-maybe-dirty' from Kleaf stamp.bzl for Bazel build."
            fi
          fi
          echo "Kernel version parameter configuration finished."

      - name: 校验关键内核配置
        run: |
          set -euo pipefail
          GKI_DEFCONFIG_TO_CHECK="${{ env.GKI_DEFCONFIG_PATH_ENV }}"
          echo "Validating kernel config options in: $GKI_DEFCONFIG_TO_CHECK"

          if [ ! -f "$GKI_DEFCONFIG_TO_CHECK" ]; then
            echo "::error::Kernel defconfig file not found for validation: $GKI_DEFCONFIG_TO_CHECK"
            exit 1
          fi

          CRITICAL_FAIL=0
          check_config() {
            local key="$1"
            local expected_value="$2"
            local is_critical="${3:-false}" # Default to not critical

            if ! grep -q "^${key}=${expected_value}$" "$GKI_DEFCONFIG_TO_CHECK"; then
              if [[ "$is_critical" == "true" ]]; then
                echo "::error::CRITICAL: ${key} is not set to '${expected_value}' in $GKI_DEFCONFIG_TO_CHECK!"
                CRITICAL_FAIL=1
              else
                echo "::warning::${key} is not set to '${expected_value}' in $GKI_DEFCONFIG_TO_CHECK."
              fi
            else
              echo "${key}=${expected_value} validated."
            fi
          }

          check_config "CONFIG_KSU" "y" "true"
          check_config "CONFIG_KSU_SUSFS" "y" "false" # Important, but maybe not build-breaking critical
          check_config "CONFIG_MODVERSIONS" "y" "false" # Recommended

          if [[ "${{ github.event.inputs.use_zram }}" == "true" ]]; then
            check_config "CONFIG_ZRAM" "y" "true"
          fi

          if [ "$CRITICAL_FAIL" -ne 0 ]; then
            echo "::error::One or more critical kernel configurations are missing or incorrect. Dumping defconfig:"
            cat "$GKI_DEFCONFIG_TO_CHECK"
            exit 1
          fi
          echo "Kernel configuration validation passed."

      - name: 编译内核 (带重试和性能分析)
        uses: nick-fields/retry@v3
        env:
          # Make BAZEL_PROFILE_PATH_IN_WORKSPACE an absolute path for clarity if used inside tools/bazel
          BAZEL_PROFILE_PATH_IN_WORKSPACE: ${{ github.workspace }}/${{ env.BAZEL_PROFILE_FILENAME }}
        with:
          timeout_minutes: 75
          max_attempts: 2
          retry_on: timeout # Retry only on timeout, not on script failure (set -e handles that)
          command: |
            set -euo pipefail
            set -x # Print commands for easier debugging

            execute_build_process() {
              cd "${{ env.KERNEL_SRC_ROOT }}" || exit 1
              BUILD_SCRIPT_PATH="./build/build.sh"
              BAZEL_DISK_CACHE_PATH="/home/runner/.cache/bazel_disk_cache" # Ensure runner has permissions
              mkdir -p "$BAZEL_DISK_CACHE_PATH"

              if [ -f "$BUILD_SCRIPT_PATH" ]; then
                echo "Using legacy build.sh script for compilation..."
                LTO=thin \
                SYSTEM_DLKM_RE_SIGN=0 \
                BUILD_SYSTEM_DLKM=0 \
                KMI_SYMBOL_LIST_STRICT_MODE=0 \
                BUILD_CONFIG=common/build.config.gki.aarch64 \
                CC="/usr/bin/ccache clang" \
                /usr/bin/time -v ./build/build.sh
                echo "Legacy build.sh completed."
              else
                echo "Using Bazel build system for compilation..."
                # Ensure BAZEL_PROFILE_PATH_IN_WORKSPACE is accessible if Bazel runs in a container or chroot
                # The path might need to be relative to the Bazel execution root if not careful.
                # Assuming execution root is KERNEL_SRC_ROOT for simplicity.
                local profile_arg_path="${BAZEL_PROFILE_PATH_IN_WORKSPACE}"
                # If tools/bazel is used, it might change current dir.
                # Using an absolute path for profile is safer.
                # tools/bazel might also map GITHUB_WORKSPACE differently if containerized.

                CMD_TO_EXEC="tools/bazel build \
                  --disk_cache=\"${BAZEL_DISK_CACHE_PATH}\" \
                  --config=fast \
                  --lto=thin \
                  --profile=\"${profile_arg_path}\" \
                  ${BAZEL_OPTIMIZATION_FLAGS} \
                  //common:kernel_aarch64_dist"

                echo "Executing Bazel command via bash -c: ${CMD_TO_EXEC}"
                /usr/bin/time -v bash -c "${CMD_TO_EXEC}"
                echo "Bazel build completed."
              fi
            }

            execute_build_process

            echo "Ccache statistics after build:"
            ccache --show-stats

            if [ -n "${CCACHE_LOGFILE}" ] && [ -f "${CCACHE_LOGFILE}" ]; then
              echo "Ccache log file (${CCACHE_LOGFILE}) size: $(du -sh ${CCACHE_LOGFILE} | cut -f1)"
              echo "Last 10 lines of ccache log:"
              tail -n 10 "${CCACHE_LOGFILE}" || true # tail can fail if file is too short
            fi

            if [ -f "${BAZEL_PROFILE_PATH_IN_WORKSPACE}" ]; then
                echo "Bazel profile generated at: ${BAZEL_PROFILE_PATH_IN_WORKSPACE}"
            else
                echo "::warning::Bazel profile file not found at ${BAZEL_PROFILE_PATH_IN_WORKSPACE}. This is normal if not a Bazel build, profiling failed, or build.sh was used."
            fi
            echo "Kernel compilation step finished."

      - name: 修补内核映像 (KPM A12/A13)
        if: env.EFFECTIVE_USE_KPM == 'true' && (env.SELECTED_ANDROID_VERSION == 'android12' || env.SELECTED_ANDROID_VERSION == 'android13') && env.SELECTED_KERNEL_VERSION != '6.6'
        run: |
          set -euo pipefail
          IMAGE_DIR_PATH="${{ env.KERNEL_SRC_ROOT }}/out/${{ env.SELECTED_ANDROID_VERSION }}-${{ env.SELECTED_KERNEL_VERSION }}/dist"
          IMAGE_FILE_PATH="$IMAGE_DIR_PATH/Image"

          echo "Checking for KPM patching (A12/A13 legacy path): $IMAGE_FILE_PATH"
          if [ -d "$IMAGE_DIR_PATH" ] && [ -f "$IMAGE_FILE_PATH" ]; then
            cd "$IMAGE_DIR_PATH" || exit 1
            echo "Downloading KPM patch_linux script..."
            curl -LSs "https://raw.githubusercontent.com/ShirkNeko/SukiSU_patch/refs/heads/main/kpm/patch_linux" -o patch_kpm
            chmod +x patch_kpm
            echo "Applying KPM patch..."
            ./patch_kpm # This script should handle its own errors or set -e will catch it
            if [ -f "oImage" ]; then # Check if patched image was created
              mv Image Image.orig_kpm
              mv oImage Image
              echo "KPM patched successfully for A12/A13 Image (legacy path)."
            else
              echo "::warning::KPM patching for A12/A13 (legacy path) did not produce oImage. Original Image kept."
            fi
          else
            echo "::warning::Image directory or Image file not found for A12/A13 KPM patching (legacy path) at $IMAGE_DIR_PATH. This might be okay if using Bazel or KPM not applicable."
          fi

      - name: 修补内核映像 (KPM A14/A15)
        if: env.EFFECTIVE_USE_KPM == 'true' && (env.SELECTED_ANDROID_VERSION == 'android14' || env.SELECTED_ANDROID_VERSION == 'android15') && env.SELECTED_KERNEL_VERSION != '6.6'
        run: |
          set -euo pipefail
          IMAGE_DIR_PATH="${{ env.KERNEL_SRC_ROOT }}/bazel-bin/common/kernel_aarch64/" # Common Bazel output
          IMAGE_FILE_PATH="$IMAGE_DIR_PATH/Image"

          echo "Checking for KPM patching (A14/A15 Bazel path): $IMAGE_FILE_PATH"
          if [ -d "$IMAGE_DIR_PATH" ] && [ -f "$IMAGE_FILE_PATH" ]; then
            cd "$IMAGE_DIR_PATH" || exit 1
            echo "Downloading KPM patch_linux script..."
            curl -LSs "https://raw.githubusercontent.com/ShirkNeko/SukiSU_patch/refs/heads/main/kpm/patch_linux" -o patch_kpm
            chmod +x patch_kpm
            echo "Applying KPM patch..."
            ./patch_kpm
            if [ -f "oImage" ]; then
              mv Image Image.orig_kpm
              mv oImage Image
              echo "KPM patched successfully for A14/A15 Image (Bazel path)."
            else
              echo "::warning::KPM patching for A14/A15 (Bazel path) did not produce oImage. Original Image kept."
            fi
          else
            echo "::warning::Image directory or Image file not found for A14/A15 KPM patching (Bazel path) at $IMAGE_DIR_PATH. This might be okay if using legacy build.sh or KPM not applicable."
          fi

      - name: 复制内核映像至AnyKernel3
        run: |
          set -euo pipefail
          IMAGE_SOURCE_PATH=""
          # Define potential paths based on build system (legacy or Bazel)
          LEGACY_IMAGE_PATH="${{ env.KERNEL_SRC_ROOT }}/out/${{ env.SELECTED_ANDROID_VERSION }}-${{ env.SELECTED_KERNEL_VERSION }}/dist/Image"
          # Bazel path can sometimes vary slightly depending on exact target and Bazel version
          BAZEL_IMAGE_PATH_PRIMARY="${{ env.KERNEL_SRC_ROOT }}/bazel-bin/common/kernel_aarch64/Image"
          BAZEL_IMAGE_PATH_ALT="${{ env.KERNEL_SRC_ROOT }}/out/android-gki/dist/Image" # Another common Bazel output

          if [ -f "$LEGACY_IMAGE_PATH" ]; then
            IMAGE_SOURCE_PATH="$LEGACY_IMAGE_PATH"
            echo "Found Image in legacy build output path: $IMAGE_SOURCE_PATH"
          elif [ -f "$BAZEL_IMAGE_PATH_PRIMARY" ]; then
            IMAGE_SOURCE_PATH="$BAZEL_IMAGE_PATH_PRIMARY"
            echo "Found Image in Bazel primary output path: $IMAGE_SOURCE_PATH"
          elif [ -f "$BAZEL_IMAGE_PATH_ALT" ]; then
            IMAGE_SOURCE_PATH="$BAZEL_IMAGE_PATH_ALT"
            echo "Found Image in Bazel alternative output path: $IMAGE_SOURCE_PATH"
          else
            echo "::error::Compiled Image file not found in expected legacy or Bazel output paths."
            echo "Listing legacy output directory contents (${{ env.KERNEL_SRC_ROOT }}/out/):"
            ls -R "${{ env.KERNEL_SRC_ROOT }}/out/" || true
            echo "Listing Bazel output directory contents (${{ env.KERNEL_SRC_ROOT }}/bazel-bin/):"
            ls -R "${{ env.KERNEL_SRC_ROOT }}/bazel-bin/" || true
            exit 1
          fi

          ANYKERNEL_DIR="$GITHUB_WORKSPACE/AnyKernel3"
          echo "Attempting to copy Image from: $IMAGE_SOURCE_PATH to $ANYKERNEL_DIR/"
          if [ ! -d "$ANYKERNEL_DIR" ]; then
            echo "::error::AnyKernel3 directory not found at $ANYKERNEL_DIR. Cannot copy Image."
            exit 1
          fi

          cp "$IMAGE_SOURCE_PATH" "$ANYKERNEL_DIR/Image"
          echo "Image successfully copied to $ANYKERNEL_DIR/Image."

      - name: 验证内核镜像类型
        run: |
          set -euo pipefail
          IMAGE_TO_VALIDATE="$GITHUB_WORKSPACE/AnyKernel3/Image"
          if [ ! -f "$IMAGE_TO_VALIDATE" ]; then
            echo "::error::Kernel Image not found at $IMAGE_TO_VALIDATE for validation."
            exit 1
          fi
          echo "Validating kernel image type: $IMAGE_TO_VALIDATE"
          file_output=$(file "$IMAGE_TO_VALIDATE")
          echo "File command output: $file_output"
          # Check for keywords indicating an ARM64 Linux kernel
          if echo "$file_output" | grep -q "ARM aarch64" && echo "$file_output" | grep -q "Linux kernel"; then
            echo "Kernel image validation successful: Looks like an ARM64 Linux kernel image."
          else
            echo "::error::Kernel image validation FAILED. Output does not match expected ARM64 Linux kernel image type."
            exit 1
          fi

      - name: 上传AnyKernel3刷机包 (Artifact)
        uses: actions/upload-artifact@v4
        with:
          name: | # Conditional naming logic seems fine
            ${{ (env.SUKI_VERSION_NUM != 'NoVer' && env.SUKI_VERSION_NUM != '' && env.SUKI_VERSION_NUM != '00000') &&
                format('AnyKernel3_SukiSUUltra_{0}_{1}-{2}{3}', env.SUKI_VERSION_NUM, env.SELECTED_KERNEL_VERSION, env.SELECTED_SUB_LEVEL, env.ARTIFACT_NAME_SUFFIX_PART) ||
                format('AnyKernel3_SukiSU_{0}_{1}-{2}{3}', 'NoVer', env.SELECTED_KERNEL_VERSION, env.SELECTED_SUB_LEVEL, env.ARTIFACT_NAME_SUFFIX_PART) }}
          path: ${{ github.workspace }}/AnyKernel3
          if-no-files-found: error # Good to fail if no files

      - name: 清理构建空间 (可选)
        if: always() # Run even if previous steps fail to maximize cleanup
        run: |
          set -euo pipefail # Use pipefail here for safety, though simple commands
          echo "Cleaning up build space..."
          # Be careful with rm -rf commands
          if [ -d "/home/runner/.cache/bazel_disk_cache" ]; then
            echo "Removing Bazel disk cache..."
            rm -rf /home/runner/.cache/bazel_disk_cache || echo "::warning::Failed to remove Bazel disk cache."
          fi
          if [ -d "$HOME/.cache/bazel" ]; then # Bazel repo cache
            echo "Removing Bazel repository cache..."
            rm -rf "$HOME/.cache/bazel" || echo "::warning::Failed to remove Bazel repository cache."
          fi
          echo "Final ccache statistics:"
          ccache -s
          echo "Build space cleanup finished."

      - name: 上传日志文件 (ccache, bazel_profile)
        if: always() # Always upload logs for debugging
        uses: actions/upload-artifact@v4
        with:
          name: build-logs-${{ env.SELECTED_ANDROID_VERSION }}-${{ env.SELECTED_KERNEL_VERSION }}-${{ github.run_id }}
          path: |
            ${{ env.CCACHE_LOGFILE }}
            ${{ github.workspace }}/${{ env.BAZEL_PROFILE_FILENAME }}
          if-no-files-found: ignore # It's okay if these files don't exist (e.g. build.sh used)

      - name: prepare_release_outputs
        id: prepare_release_outputs
        shell: bash
        run: |
          set -euo pipefail
          _suki_ver_num_for_name_prep="${{ env.SUKI_VERSION_NUM }}"
          _kernel_ver="${{ env.SELECTED_KERNEL_VERSION }}"
          _sub_level="${{ env.SELECTED_SUB_LEVEL }}"
          _suffix_part="${{ env.ARTIFACT_NAME_SUFFIX_PART }}"
          _artifact_name_for_upload_internal=""
          _new_release_base_name="SukiSUUltra" # Base name for releases
          _final_release_title=""
          _final_release_tag=""

          if [[ "$_suki_ver_num_for_name_prep" != "NoVer" && "$_suki_ver_num_for_name_prep" =~ ^[0-9]+$ && "$_suki_ver_num_for_name_prep" != "00000" && "$_suki_ver_num_for_name_prep" != "10000" ]]; then
            _artifact_name_for_upload_internal="AnyKernel3_${_new_release_base_name}_${_suki_ver_num_for_name_prep}_${_kernel_ver}-${_sub_level}${_suffix_part}"
            _final_release_title="${_new_release_base_name}-${_suki_ver_num_for_name_prep}"
            # Ensure tag is somewhat unique if suffix part can be empty for custom versions
            _final_release_tag="${_new_release_base_name}-${_suki_ver_num_for_name_prep}_${_kernel_ver}-${_sub_level}${_suffix_part:-$(date +%s)}"
          else
            _actual_suffix_for_fallback="${_suffix_part}"
            if [[ -z "$_actual_suffix_for_fallback" && "${{ github.event.inputs.custom_version_suffix }}" == "" ]]; then
              _actual_suffix_for_fallback="-$(date +%Y%m%d)" # Ensure fallback has a date
            fi
            _artifact_name_for_upload_internal="AnyKernel3_${_new_release_base_name}_NoVer_${_kernel_ver}-${_sub_level}${_actual_suffix_for_fallback}"
            _final_release_title="${_new_release_base_name}-NoVer${_actual_suffix_for_fallback}"
            _final_release_tag="${_new_release_base_name}-NoVer_${_kernel_ver}-${_sub_level}${_actual_suffix_for_fallback}"
          fi

          # Sanitize names for artifacts and tags (GitHub has restrictions)
          _artifact_name_cleaned_for_output=$(echo "$_artifact_name_for_upload_internal" | sed 's/[^a-zA-Z0-9._\-\(\)]/-/g')
          echo "artifact_name_for_release=${_artifact_name_cleaned_for_output}" >> "$GITHUB_OUTPUT"

          _final_release_tag_cleaned=$(echo "$_final_release_tag" | sed 's/[^a-zA-Z0-9._\-\(\)]/-/g')
          _final_release_title_cleaned="${_final_release_title}" # Title can be more freeform

          echo "release_tag_name=${_final_release_tag_cleaned}" >> "$GITHUB_OUTPUT"
          echo "release_title_name=${_final_release_title_cleaned}" >> "$GITHUB_OUTPUT"
          echo "Release outputs prepared: Artifact Name='$_artifact_name_cleaned_for_output', Tag='$_final_release_tag_cleaned', Title='$_final_release_title_cleaned'"

  create_release:
    name: 创建 GitHub Release
    needs: build_kernel
    permissions:
      contents: write # Essential for creating releases
    runs-on: ubuntu-latest
    if: success() && github.event.inputs.upload_to_release == 'true'
    steps:
      - name: 安装 zip 工具
        run: |
          set -euo pipefail
          sudo apt-get update -qq
          sudo DEBIAN_FRONTEND=noninteractive apt-get install -yq --no-install-recommends zip

      - name: 下载内核刷机包 (Artifact)
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.build_kernel.outputs.artifact_name }}
          path: downloaded_artifact/ # Trailing slash indicates a directory

      - name: 准备刷机包并设置路径
        id: package_kernel
        shell: bash
        run: |
          set -euo pipefail
          cd downloaded_artifact
          # Ensure artifact name from previous job is filesystem-safe for the zip file name
          zip_file_name_base="${{ needs.build_kernel.outputs.artifact_name }}"
          zip_file_name_final="${zip_file_name_base}.zip"

          if [ -z "$(ls -A .)" ]; then # Check if directory is empty
            echo "::error title=打包失败::downloaded_artifact 目录为空，无法创建 ${zip_file_name_final}"
            exit 1
          fi

          echo "Creating zip file: ../${zip_file_name_final} from contents of $(pwd)"
          # Zip contents of current directory (downloaded_artifact)
          zip -r9 "../${zip_file_name_final}" .
          cd ..

          if [ ! -f "${zip_file_name_final}" ]; then
            echo "::error title=打包失败::未能创建 ${zip_file_name_final}"
            exit 1
          fi

          echo "Packaged zip file: ${zip_file_name_final}"
          echo "packaged_zip=${zip_file_name_final}" >> $GITHUB_OUTPUT

      - name: 创建 Release 并上传刷机包
        uses: ncipollo/release-action@v1 # Consider pinning to a specific commit/tag for stability
        with:
          artifacts: ${{ steps.package_kernel.outputs.packaged_zip }}
          tag: ${{ needs.build_kernel.outputs.release_tag }}
          name: ${{ needs.build_kernel.outputs.release_title }}
          body: | # Release body content seems fine
            自动构建的内核发行版。

            **核心信息:**
            - 内核版本构建输入: `${{ github.event.inputs.kernel_to_build }}`
            - SukiSU 版本 (计算): `${{ needs.build_kernel.outputs.sukisu_version_from_build_job }}`
            - SukiSU 功能分支: `${{ github.event.inputs.kernelsu_branch }}`
            - 自定义版本后缀 (如有): `${{ github.event.inputs.custom_version_suffix == '' && '仿官方随机生成' || format('自定义: {0}', github.event.inputs.custom_version_suffix) }}`
            - 内核名 (LOCALVERSION): `${{ needs.build_kernel.outputs.parsed_kernel_version_output }}.${{ needs.build_kernel.outputs.parsed_sub_level_output }}${{ needs.build_kernel.outputs.final_kernel_local_version_output }}`
            - 构建日期: `${{ needs.build_kernel.outputs.current_build_date_formatted_output }}`

            **构建选项:**
            - 使用ZRAM: `${{ github.event.inputs.use_zram }}`
            - 使用KPM: `${{ needs.build_kernel.outputs.effective_kpm_setting }}` (实际生效的KPM设置)

            ---
            *SHA: `${{ github.sha }}`*
            *构建ID: `${{ github.run_id }}`*
          token: ${{ secrets.GITHUB_TOKEN }}
          allowUpdates: true # Useful for re-running builds for the same tag