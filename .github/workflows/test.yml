name: 内核编译
permissions:
  contents: write
  actions: write

# 一、并发控制优化 (已实现)
# 通过组合分支名和内核版本参数实现精确的并发控制
concurrency:
  group: kernel-build-${{ github.ref }}-${{ github.event.inputs.kernel_to_build }}
  cancel-in-progress: true

on:
  workflow_dispatch:
    inputs:
      kernel_to_build:
        description: "选择内核版本"
        required: true
        type: choice
        options:
          - "android12_5.10_168_2023-04_r9"
          - "android12_5.10_198_2024-01_r17"
          - "android12_5.10_205_2024-03_r9"
          - "android12_5.10_209_2024-05_r13"
          - "android12_5.10_218_2024-08_r14"
          - "android12_5.10_226_2024-11_r8"
          - "android12_5.10_233_2025-02_r1"
          - "android12_5.10_X_lts_r1"
          - "android13_5.10_198_2024-01_"
          - "android13_5.10_205_2024-03_"
          - "android13_5.10_209_2024-05_"
          - "android13_5.10_214_2024-07_"
          - "android13_5.10_218_2024-08_"
          - "android13_5.10_223_2024-11_"
          - "android13_5.10_228_2025-01_"
          - "android13_5.10_X_lts_"
          - "android13_5.15_123_2023-11_"
          - "android13_5.15_137_2024-01_"
          - "android13_5.15_144_2024-03_"
          - "android13_5.15_148_2024-05_"
          - "android13_5.15_151_2024-08_"
          - "android13_5.15_167_2024-11_"
          - "android13_5.15_170_2025-01_"
          - "android13_5.15_X_lts_"
          - "android14_5.15_131_2023-11_"
          - "android14_5.15_137_2024-01_"
          - "android14_5.15_144_2024-03_"
          - "android14_5.15_148_2024-05_"
          - "android14_5.15_149_2024-06_"
          - "android14_5.15_153_2024-07_"
          - "android14_5.15_158_2024-08_"
          - "android14_5.15_167_2024-11_"
          - "android14_5.15_170_2025-01_"
          - "android14_6.1_75_2024-05_"
          - "android15_6.6_50_2024-10_"
          - "android15_6.6_56_2024-11_"
          - "android15_6.6_57_2024-12_"
          - "android15_6.6_58_2025-01_"
          - "android15_6.6_66_2025-02_"
          - "android15_6.6_77_2025-03_"
          - "android15_6.6_X_lts_"
        default: "android14_6.1_75_2024-05_"
      kernelsu_branch:
        description: "选择SukiSU功能分支"
        required: true
        type: choice
        options:
          - Stable
          - Dev
          - Other
        default: Dev
      custom_version_suffix:
        description: '自定义内核版本后缀 (留空仿官方)'
        required: false
        type: string
      use_zram:
        description: '启用额外ZRAM算法'
        required: true
        type: boolean
        default: true
      use_kpm:
        description: '启用KPM功能'
        required: true
        type: boolean
        default: true
      upload_to_release:
        description: '是否上传到 GitHub Release'
        required: true
        type: choice
        options:
          - 'true'
          - 'false'
        default: 'true'

jobs:
  determine_sukisu_version:
    name: 获取SukiSU版本
    runs-on: ubuntu-latest
    outputs:
      job_name_suffix: ${{ steps.calculate_version.outputs.job_suffix }}
      sukisu_version: ${{ steps.calculate_version.outputs.suki_version_actual }}
    steps:
      - name: 安装Git
        run: sudo apt-get update && sudo apt-get install -y git
      - name: 计算SukiSU版本号
        id: calculate_version
        shell: bash
        run: |
          suki_version_actual_for_output="获取失败"
          job_suffix_text=""
          SUKI_REPO_URL="https://github.com/ShirkNeko/SukiSU-Ultra.git"
          CLONE_BRANCH="main"
          if git clone --branch "$CLONE_BRANCH" --single-branch "$SUKI_REPO_URL" SukiSU_temp_for_version; then
            cd SukiSU_temp_for_version
            commit_count=$(git rev-list --count HEAD 2>/dev/null || echo 0)
            if [[ "$commit_count" -ne "0" && "$commit_count" != "err"* ]]; then
              calculated_version=$(expr $commit_count + 10606) # 假设这是正确的计算逻辑
              suki_version_actual_for_output=$calculated_version
              job_suffix_text=" (SukiSU $calculated_version)"
            else
              suki_version_actual_for_output="计算错误"
              job_suffix_text=" (SukiSU - 版本计算失败)"
            fi
            cd ..
            rm -rf SukiSU_temp_for_version
          else
            suki_version_actual_for_output="克隆错误"
            job_suffix_text=" (SukiSU - 克隆失败)"
          fi
          echo "job_suffix=${job_suffix_text}" >> $GITHUB_OUTPUT
          echo "suki_version_actual=${suki_version_actual_for_output}" >> $GITHUB_OUTPUT

  build_kernel:
    name: 内核编译 (SukiSU) - ${{ github.event.inputs.kernel_to_build }}${{ needs.determine_sukisu_version.outputs.job_name_suffix }}
    needs: determine_sukisu_version
    # 五、编译环境隔离优化 (可选，如启用需自行构建并推送Docker镜像，并移除后续的apt依赖安装步骤)
    # container:
    #   image: your-docker-registry/android-kernel-builder:v2025.05 # 替换为您的镜像地址
    #   credentials:
    #     username: ${{ secrets.DOCKER_USER }} # 如果镜像是私有的
    #     password: ${{ secrets.DOCKER_PASS }} # 如果镜像是私有的
    runs-on: ubuntu-latest # 如果不使用容器，则在此运行器上执行
    outputs:
      artifact_name: ${{ steps.prepare_release_outputs.outputs.artifact_name_for_release }}
      release_tag: ${{ steps.prepare_release_outputs.outputs.release_tag_name }}
      release_title: ${{ steps.prepare_release_outputs.outputs.release_title_name }}
      final_kernel_local_version_output: ${{ steps.generate_suffixes.outputs.final_kernel_local_version_for_release_body }}
      current_build_date_formatted_output: ${{ steps.generate_suffixes.outputs.current_build_date_formatted_for_release_body }}
      parsed_kernel_version_output: ${{ steps.parse_kernel.outputs.parsed_kernel_version }}
      parsed_sub_level_output: ${{ steps.parse_kernel.outputs.parsed_sub_level }}
      sukisu_version_from_build_job: ${{ needs.determine_sukisu_version.outputs.sukisu_version }}
      # 将GKI defconfig路径输出，用于后续配置校验步骤
      gki_defconfig_path_output: ${{ steps.set_gki_defconfig_path.outputs.gki_defconfig_path }}
    env:
      CCACHE_COMPILERCHECK: "%compiler% -dumpmachine; %compiler% -dumpversion"
      CCACHE_NOHASHDIR: "true"
      CCACHE_HARDLINK: "true"
      SUKI_VERSION_NUM_FROM_PREVIOUS_JOB: ${{ needs.determine_sukisu_version.outputs.sukisu_version }}
      # 二、Bazel编译深度优化参数
      BAZEL_OPTIMIZATION_FLAGS: >- # 使用 >- 保留换行符并去除末尾换行
        --jobs=$(($(nproc) * 3))
        --local_ram_resources=HOST_RAM*0.8
        # --remote_cache=grpc://your-cache-server.example.com:port # 可选：启用远程缓存，需自行配置服务器
      # 日志优化
      CCACHE_LOGFILE: /tmp/ccache.log
      BAZEL_PROFILE_FILENAME: bazel_profile.json # 定义profile文件名，方便引用

    steps:
      - name: 解析内核参数
        id: parse_kernel
        run: |
          IFS='_' read -r av kv sl opl rev_raw <<< "${{ github.event.inputs.kernel_to_build }}"
          echo "SELECTED_ANDROID_VERSION=$av" >> $GITHUB_ENV
          echo "SELECTED_KERNEL_VERSION=$kv" >> $GITHUB_ENV
          echo "SELECTED_SUB_LEVEL=$sl" >> $GITHUB_ENV
          echo "SELECTED_OS_PATCH_LEVEL=$opl" >> $GITHUB_ENV
          rev="${rev_raw:-}"
          echo "SELECTED_REVISION=$rev" >> $GITHUB_ENV
          echo "parsed_kernel_version=$kv" >> $GITHUB_OUTPUT
          echo "parsed_sub_level=$sl" >> $GITHUB_OUTPUT

      - name: 生成版本后缀和日期
        id: generate_suffixes
        env:
          USER_PROVIDED_SUFFIX: ${{ github.event.inputs.custom_version_suffix }}
          SELECTED_AV_ENV: ${{ env.SELECTED_ANDROID_VERSION }}
          SELECTED_KV_ENV: ${{ env.SELECTED_KERNEL_VERSION }}
        run: |
          final_kernel_local_version=""
          artifact_name_suffix_part=""
          current_date_yyyymmdd=$(date +%Y%m%d)
          current_date_formatted=$(date +"%Y年%m月%d日")

          if [[ -n "$USER_PROVIDED_SUFFIX" ]]; then
            final_kernel_local_version="$USER_PROVIDED_SUFFIX"
            artifact_name_suffix_part="$USER_PROVIDED_SUFFIX" # 如果有自定义后缀，产物名也用它
          else
            kernel_fixed_part_for_localversion=""
            # ... (此部分逻辑保持不变，用于生成默认的内核版本后缀)
            if [ "$SELECTED_AV_ENV" == "android12" ] && [ "$SELECTED_KV_ENV" == "5.10" ]; then
              kernel_fixed_part_for_localversion="-android12-9"
            elif [ "$SELECTED_AV_ENV" == "android13" ] && [ "$SELECTED_KV_ENV" == "5.10" ]; then
              kernel_fixed_part_for_localversion="-android13-9"
            elif [ "$SELECTED_AV_ENV" == "android13" ] && [ "$SELECTED_KV_ENV" == "5.15" ]; then
              kernel_fixed_part_for_localversion="-android13-8"
            elif [ "$SELECTED_AV_ENV" == "android14" ] && [ "$SELECTED_KV_ENV" == "6.1" ]; then
              kernel_fixed_part_for_localversion="-android14-11"
            elif [ "$SELECTED_AV_ENV" == "android15" ] && [ "$SELECTED_KV_ENV" == "6.6" ]; then
              kernel_fixed_part_for_localversion="-android15-8"
            else
              kernel_fixed_part_for_localversion="-${SELECTED_AV_ENV}-${SELECTED_KV_ENV//./_}-custom"
            fi
            prefix1="gd"
            prefix2="ab"
            random_hex_11=$(head /dev/urandom | LC_ALL=C tr -dc 'a-f0-9' | head -c 11 || true)
            random_digits_8=$(head /dev/urandom | LC_ALL=C tr -dc '0-9' | head -c 8 || true)
            final_kernel_local_version="${kernel_fixed_part_for_localversion}-${prefix1}${random_hex_11}-${prefix2}${random_digits_8}"
            artifact_name_suffix_part="-${current_date_yyyymmdd}" # 默认产物名后缀用日期
          fi
          echo "FINAL_KERNEL_LOCAL_VERSION=${final_kernel_local_version}" >> "$GITHUB_ENV"
          echo "ARTIFACT_NAME_SUFFIX_PART=${artifact_name_suffix_part}" >> "$GITHUB_ENV"
          echo "final_kernel_local_version_for_release_body=${final_kernel_local_version}" >> $GITHUB_OUTPUT
          echo "current_build_date_formatted_for_release_body=${current_date_formatted}" >> $GITHUB_OUTPUT

      - name: 调整KPM设置
        run: |
          if [[ "${{ env.SELECTED_ANDROID_VERSION }}" == "android15" && "${{ env.SELECTED_KERNEL_VERSION }}" == "6.6" ]]; then
            echo "EFFECTIVE_USE_KPM=false" >> $GITHUB_ENV
          else
            echo "EFFECTIVE_USE_KPM=${{ github.event.inputs.use_kpm }}" >> $GITHUB_ENV
          fi

      - name: 优化构建空间
        # 如果使用自定义Docker容器并且容器已优化，此步骤可能不需要或需要调整
        uses: easimon/maximize-build-space@master
        with:
          root-reserve-mb: 8192
          temp-reserve-mb: 2048
          swap-size-mb: 8192 # 保持固定值，或根据运行器规格手动调整
          remove-dotnet: "true"
          remove-android: "true"
          remove-haskell: "true"
          remove-codeql: "true"

      - name: 设置CONFIG环境变量和GKI Defconfig路径
        id: set_gki_defconfig_path
        run: |
          JOB_CONFIG="${{ env.SELECTED_ANDROID_VERSION }}-${{ env.SELECTED_KERNEL_VERSION }}-${{ env.SELECTED_SUB_LEVEL }}"
          echo "CONFIG=$JOB_CONFIG" >> $GITHUB_ENV
          GKI_DEFCONFIG_FULL_PATH="${GITHUB_WORKSPACE}/${JOB_CONFIG}/common/arch/arm64/configs/gki_defconfig"
          echo "GKI_DEFCONFIG_PATH_ENV=${GKI_DEFCONFIG_FULL_PATH}" >> $GITHUB_ENV
          echo "gki_defconfig_path=${GKI_DEFCONFIG_FULL_PATH}" >> $GITHUB_OUTPUT


      - name: 安装ccache及依赖
        # 如果使用自定义Docker容器并且已包含这些依赖，则此步骤应被移除或注释掉
        run: sudo apt update && sudo apt upgrade -y && sudo apt install -y ccache python3 git curl time

      - name: 配置ccache
        run: |
          mkdir -p ~/.cache/bazel # Bazel 可能会用到
          echo "当前ccache版本信息:"
          ccache --version # 这会显示版本和Features
          
          ccache --max-size=2G # 您可以根据需要调整缓存大小
          ccache --set-config=compression=true # 启用压缩（这是默认行为，但明确设置无妨）
          
          # 检查ccache是否支持Zstd
          if ccache --version | grep -q 'Zstd'; then
            echo "检测到ccache支持Zstd。设置 compression_type 为 zstd。"
            ccache --set-config=compression_type=zstd
          else
            echo "未检测到ccache支持Zstd。将使用默认的压缩类型 (通常是zlib)。"
            # 如果需要，可以明确设置为zlib，但通常如果Zstd不可用，zlib就是默认值
            # ccache --set-config=compression_type=zlib
            # 由于 Zstd 不可用，compression_type 选项本身可能也无效，所以这里不尝试设置回zlib，
            # 让 ccache 在 compression=true 的情况下使用其唯一的/默认的压缩算法。
          fi
          
          echo "CCACHE_DIR=$HOME/.ccache" >> $GITHUB_ENV
          echo "当前ccache配置统计信息:"
          ccache -s # 显示配置和统计信息

      - name: 缓存预编译工具链
        id: cache-toolchain
        uses: actions/cache@v4
        with:
          path: |
            kernel-build-tools
            mkbootimg
          key: toolchain-${{ runner.os }}-v2 # 版本号可根据工具链更新情况调整

      - name: 下载预编译工具链 (若缓存未命中)
        # 如果使用自定义Docker容器并且已包含这些工具链，则此步骤应被移除或注释掉
        if: steps.cache-toolchain.outputs.cache-hit != 'true'
        run: |
          AOSP_MIRROR=https://android.googlesource.com
          # 确保分支名是最新的或者稳定的
          BUILD_TOOLS_BRANCH=main-kernel-build-2024 # 示例，请确认最新的GKI构建工具分支
          MKBOOTIMG_BRANCH=main # 通常 mkbootimg 在 main 分支
          git clone $AOSP_MIRROR/kernel/prebuilts/build-tools -b $BUILD_TOOLS_BRANCH --depth 1 kernel-build-tools
          git clone $AOSP_MIRROR/platform/system/tools/mkbootimg -b $MKBOOTIMG_BRANCH --depth 1 mkbootimg

      - name: 设置工具链环境变量
        run: |
          echo "AVBTOOL=$GITHUB_WORKSPACE/kernel-build-tools/linux-x86/bin/avbtool" >> $GITHUB_ENV
          echo "MKBOOTIMG=$GITHUB_WORKSPACE/mkbootimg/mkbootimg.py" >> $GITHUB_ENV
          echo "UNPACK_BOOTIMG=$GITHUB_WORKSPACE/mkbootimg/unpack_bootimg.py" >> $GITHUB_ENV

      - name: 设置签名密钥
        env:
          BOOT_SIGN_KEY: ${{ secrets.BOOT_SIGN_KEY }}
        run: |
          KEY_DIR="$GITHUB_WORKSPACE/kernel-build-tools/linux-x86/share/avb"
          mkdir -p "$KEY_DIR"
          if [ -z "$BOOT_SIGN_KEY" ]; then
            echo "BOOT_SIGN_KEY secret is not set. Generating a test key."
            openssl genpkey -algorithm RSA -pkeyopt rsa_keygen_bits:2048 > "$KEY_DIR/testkey_rsa2048.pem"
            echo "BOOT_SIGN_KEY_PATH=$KEY_DIR/testkey_rsa2048.pem" >> $GITHUB_ENV
          else
            echo "Using BOOT_SIGN_KEY from secrets."
            echo "$BOOT_SIGN_KEY" > "$KEY_DIR/production_key.pem"
            echo "BOOT_SIGN_KEY_PATH=$KEY_DIR/production_key.pem" >> $GITHUB_ENV
          fi

      - name: 安装repo工具
        # 如果使用自定义Docker容器并且已包含repo，则此步骤应被移除或注释掉
        run: |
          mkdir -p ./git-repo
          curl https://storage.googleapis.com/git-repo-downloads/repo > ./git-repo/repo
          chmod a+rx ./git-repo/repo
          echo "REPO=$GITHUB_WORKSPACE/./git-repo/repo" >> $GITHUB_ENV

      - name: 检查依赖项安全 (可选)
        uses: actions/dependency-review-action@v4
        with:
          # 对于 workflow_dispatch 事件，我们需要明确指定 base-ref 和 head-ref。
          # 以下配置尝试比较当前提交与其直接父提交。
          # 注意: 如果在仓库的第一个提交上运行此工作流，获取父提交 (~) 可能会失败。
          base-ref: ${{ github.sha }}~1 # 指向当前提交的第一个父提交
          head-ref: ${{ github.sha }}   # 指向当前提交
          
          fail-on-severity: high # 依赖项审查失败的级别 (例如: critical, high, moderate, low)
          allow-licenses: MIT, Apache-2.0, GPL-2.0, BSD-3-Clause # 允许的许可证列表，请根据您的项目调整
          # repo-token: ${{ secrets.GITHUB_TOKEN }} # GITHUB_TOKEN 会自动被 Action 使用，通常不需要显式传递

          # 由于此步骤是可选的，并且在某些边缘情况下可能失败（如仓库的初始提交），
          # 设置 continue-on-error 为 true 可以允许工作流在这一步失败时继续。
          continue-on-error: true

      - name: 克隆依赖仓库 (AnyKernel3等)
        run: |
          ANYKERNEL_BRANCH="gki-2.0" # 确保此分支有效
          SUSFS_BRANCH_SPECIFIC="gki-${{ env.SELECTED_ANDROID_VERSION }}-${{ env.SELECTED_KERNEL_VERSION }}"
          SUSFS_BRANCH_FALLBACK="main"

          git clone https://github.com/WildPlusKernel/AnyKernel3.git -b "$ANYKERNEL_BRANCH" AnyKernel3
          
          echo "Attempting to clone susfs4ksu with branch: $SUSFS_BRANCH_SPECIFIC"
          if ! git clone https://gitlab.com/simonpunk/susfs4ksu.git -b "$SUSFS_BRANCH_SPECIFIC" susfs4ksu; then
            echo "Failed to clone with branch $SUSFS_BRANCH_SPECIFIC, trying fallback branch $SUSFS_BRANCH_FALLBACK"
            git clone https://gitlab.com/simonpunk/susfs4ksu.git -b "$SUSFS_BRANCH_FALLBACK" susfs4ksu
          fi
          
          git clone https://github.com/WildPlusKernel/kernel_patches.git kernel_patches
          git clone https://github.com/ShirkNeko/SukiSU_patch.git SukiSU_patch

      - name: 同步内核源码
        run: |
          # ... (同步内核源码逻辑基本保持不变, 但注意 FORMATTED_BRANCH 的确定)
          mkdir -p "${{ env.CONFIG }}"
          cd "${{ env.CONFIG }}"
          # 构造 manifest 分支名，需要仔细处理 LTS 和不带 revision 的情况
          # 这一部分的逻辑非常依赖 AOSP manifest 的实际分支命名规则
          # 以下是一个尝试性的通用化处理，您可能需要根据实际情况微调
          _MANIFEST_BRANCH_BASE="common-${{ env.SELECTED_ANDROID_VERSION }}-${{ env.SELECTED_KERNEL_VERSION }}"
          if [[ -n "${{ env.SELECTED_OS_PATCH_LEVEL }}" && "${{ env.SELECTED_OS_PATCH_LEVEL }}" != "X" ]]; then
            _MANIFEST_BRANCH="${_MANIFEST_BRANCH_BASE}-${{ env.SELECTED_OS_PATCH_LEVEL }}"
          elif [[ "${{ github.event.inputs.kernel_to_build }}" == *"_X_lts_"* || "${{ github.event.inputs.kernel_to_build }}" == *"_lts_"* ]]; then
             _MANIFEST_BRANCH="${_MANIFEST_BRANCH_BASE}-lts" # 假设lts分支有-lts后缀
             # 或者某些lts分支可能就是 _MANIFEST_BRANCH_BASE，没有额外后缀
          else
             _MANIFEST_BRANCH="${_MANIFEST_BRANCH_BASE}"
          fi
          echo "Using manifest branch: $_MANIFEST_BRANCH for repo init"

          $REPO init --depth=1 -u https://android.googlesource.com/kernel/manifest -b $_MANIFEST_BRANCH --repo-rev=v2.16 # 使用经过推断的分支名
          
          DEFAULT_MANIFEST_PATH=".repo/manifests/default.xml"
          if [ ! -f $DEFAULT_MANIFEST_PATH ] && [ -f .repo/manifest.xml ]; then
            DEFAULT_MANIFEST_PATH=.repo/manifest.xml
          fi

          # 针对 common 项目的 deprecated 分支处理 (如果适用)
          # 注意: 这里的逻辑假设 common 项目的 revision 与 manifest 的 -b 参数所指定的分支名一致或类似
          # 一个更鲁棒的方法是解析 manifest 文件来获取 common 项目的确切 revision
          COMMON_PROJECT_REVISION_IN_MANIFEST=$(grep 'project path="common"' $DEFAULT_MANIFEST_PATH | sed -n 's/.*revision="\([^"]*\)".*/\1/p' | head -n 1)
          if [ -z "$COMMON_PROJECT_REVISION_IN_MANIFEST" ]; then
              COMMON_PROJECT_REVISION_IN_MANIFEST=$_MANIFEST_BRANCH # Fallback
          fi
          
          REMOTE_COMMON_BRANCH_STATUS=$(git ls-remote https://android.googlesource.com/kernel/common $COMMON_PROJECT_REVISION_IN_MANIFEST)
          if echo "$REMOTE_COMMON_BRANCH_STATUS" | grep -q "deprecated/$COMMON_PROJECT_REVISION_IN_MANIFEST"; then
             echo "Common kernel branch '$COMMON_PROJECT_REVISION_IN_MANIFEST' is deprecated. Adjusting manifest for 'deprecated/' prefix."
             # 更精确地替换 common 项目的 revision
             sed -i "/project path=\"common\"/s|revision=\"$COMMON_PROJECT_REVISION_IN_MANIFEST\"|revision=\"deprecated/$COMMON_PROJECT_REVISION_IN_MANIFEST\"|" $DEFAULT_MANIFEST_PATH || \
             sed -i "/project path=\"kernel\/common\"/s|revision=\"$COMMON_PROJECT_REVISION_IN_MANIFEST\"|revision=\"deprecated/$COMMON_PROJECT_REVISION_IN_MANIFEST\"|" $DEFAULT_MANIFEST_PATH
             echo "Manifest potentially updated to use deprecated/ branch for common project."
          fi
          
          $REPO --trace sync -c -j$(nproc --all) --no-tags --fail-fast --current-branch

      - name: 设置SukiSU分支参数
        run: |
          KSU_SETUP_BRANCH_ARG=""
          if [[ "${{ github.event.inputs.kernelsu_branch }}" == "Stable" ]]; then
            KSU_SETUP_BRANCH_ARG=""
          elif [[ "${{ github.event.inputs.kernelsu_branch }}" == "Dev" ]]; then
            KSU_SETUP_BRANCH_ARG="-s susfs-dev" # 确保 setup.sh 支持此参数
          elif [[ "${{ github.event.inputs.kernelsu_branch }}" == "Other" ]]; then
            KSU_SETUP_BRANCH_ARG="" # 自定义 "Other" 的行为
          fi
          echo "KSU_BRANCH_ARG=${KSU_SETUP_BRANCH_ARG}" >> $GITHUB_ENV

      - name: 集成SukiSU
        run: |
          cd "${{ env.CONFIG }}"
          # SukiSU setup.sh 脚本的参数化执行
          curl -LSs "https://raw.githubusercontent.com/ShirkNeko/SukiSU-Ultra/main/kernel/setup.sh" | bash -s -- ${{ env.KSU_BRANCH_ARG }}

      - name: 设置SukiSU版本号
        shell: bash
        run: |
          final_suki_version_num_for_env="${{ needs.determine_sukisu_version.outputs.sukisu_version }}"
          if [[ "$final_suki_version_num_for_env" =~ ^[0-9]+$ ]]; then
            echo "SUKI_VERSION_NUM=$final_suki_version_num_for_env" >> $GITHUB_ENV
          else
            echo "SUKI_VERSION_NUM=NoVer" >> $GITHUB_ENV
          fi

      - name: 并行应用内核补丁
        shell: bash
        run: |
          # 注意：此步骤中的各个补丁应用函数并行执行。
          # 请确保这些补丁是设计为可以独立应用的，或者它们操作的是源码树的不同部分，以避免冲突。
          # 如果补丁之间存在依赖或冲突，应将它们串行化或采用更细粒度的锁机制。
          # 全局flock锁会使此步骤完全串行化，失去并行优势。
          echo "Starting parallel patch application..."
          COMMON_DIR_PATH="${GITHUB_WORKSPACE}/${{ env.CONFIG }}/common"
          # ... (apply_susfs_patch, apply_hooks_patch, apply_zram_compression_patches, apply_hide_stuff_patch 函数定义保持不变) ...
          apply_susfs_patch() {
            echo "Applying SUSFS patches..."
            cd "$COMMON_DIR_PATH"
            SUSFS_PATCH_FILE_NAME="50_add_susfs_in_gki-${{ env.SELECTED_ANDROID_VERSION }}-${{ env.SELECTED_KERNEL_VERSION }}.patch"
            if [ -f "${GITHUB_WORKSPACE}/susfs4ksu/kernel_patches/${SUSFS_PATCH_FILE_NAME}" ]; then
                cp "${GITHUB_WORKSPACE}/susfs4ksu/kernel_patches/${SUSFS_PATCH_FILE_NAME}" ./ || echo "SUSFS common patch copy failed"
            else
                echo "SUSFS common patch file not found: ${GITHUB_WORKSPACE}/susfs4ksu/kernel_patches/${SUSFS_PATCH_FILE_NAME}"
            fi
            if [ -d "${GITHUB_WORKSPACE}/susfs4ksu/kernel_patches/fs" ]; then
                cp -r "${GITHUB_WORKSPACE}/susfs4ksu/kernel_patches/fs/." ./fs/ || echo "SUSFS fs dir copy failed"
            else
                echo "SUSFS fs dir not found: ${GITHUB_WORKSPACE}/susfs4ksu/kernel_patches/fs"
            fi
            if [ -d "${GITHUB_WORKSPACE}/susfs4ksu/kernel_patches/include/linux" ]; then
                mkdir -p ./include/linux
                cp -r "${GITHUB_WORKSPACE}/susfs4ksu/kernel_patches/include/linux/." ./include/linux/ || echo "SUSFS include dir copy failed"
            else
                echo "SUSFS include/linux dir not found: ${GITHUB_WORKSPACE}/susfs4ksu/kernel_patches/include/linux"
            fi
            if [ -f "./${SUSFS_PATCH_FILE_NAME}" ]; then
              patch -p1 --fuzz=3 < "./${SUSFS_PATCH_FILE_NAME}" || echo "SUSFS patch application failed for $SUSFS_PATCH_FILE_NAME"
            else
              echo "SUSFS patch file not found for application: ./${SUSFS_PATCH_FILE_NAME}"
            fi
            FORMATTED_BRANCH_FOR_FIX_COMPARE="${{ env.SELECTED_ANDROID_VERSION }}-${{ env.SELECTED_KERNEL_VERSION }}-${{ env.SELECTED_OS_PATCH_LEVEL }}" # 假设OS_PATCH_LEVEL格式固定
            if [[ "$FORMATTED_BRANCH_FOR_FIX_COMPARE" == "android15-6.6-2024-08" || "$FORMATTED_BRANCH_FOR_FIX_COMPARE" == "android15-6.6-2024-09" ]]; then # 确保这里的日期格式与您的输入一致
              echo "Applying fix for 6.6 kernel (android15-6.6-2024-08/09)..."
              curl -LSs https://github.com/zzh20188/GKI_KernelSU_SUSFS/raw/refs/heads/fix/fix6.6.patch -o fix6.6.patch
              patch -p1 < fix6.6.patch || echo "Fix patch for 6.6 failed"
            fi
            echo "SUSFS patches finished."
          }
          apply_hooks_patch() {
            echo "Applying SukiSU hooks patch..."
            cd "$COMMON_DIR_PATH"
            HOOKS_PATCH_FILE="${GITHUB_WORKSPACE}/SukiSU_patch/hooks/syscall_hooks.patch"
            if [ -f "$HOOKS_PATCH_FILE" ]; then
              cp "$HOOKS_PATCH_FILE" ./syscall_hooks.patch
              patch -p1 -F 3 < syscall_hooks.patch || echo "SukiSU hooks patch failed"
            else
              echo "SukiSU hooks patch file not found: $HOOKS_PATCH_FILE"
            fi
            echo "SukiSU hooks patch finished."
          }
          apply_zram_compression_patches() {
            if [[ "${{ github.event.inputs.use_zram }}" == "true" ]]; then
              echo "Applying additional ZRAM compression patches..."
              cd "$COMMON_DIR_PATH"
              ZRAM_PATCH_BASE="${GITHUB_WORKSPACE}/SukiSU_patch/other/zram"
              if [ -d "${ZRAM_PATCH_BASE}/lz4k/include/linux" ]; then
                mkdir -p ./include/linux
                cp -r "${ZRAM_PATCH_BASE}/lz4k/include/linux/." ./include/linux/ || echo "lz4k include copy failed"
              fi
              if [ -d "${ZRAM_PATCH_BASE}/lz4k/lib" ]; then
                cp -r "${ZRAM_PATCH_BASE}/lz4k/lib/." ./lib/ || echo "lz4k lib copy failed"
              fi
              if [ -d "${ZRAM_PATCH_BASE}/lz4k/crypto" ]; then
                cp -r "${ZRAM_PATCH_BASE}/lz4k/crypto/." ./crypto/ || echo "lz4k crypto copy failed"
              fi
              if [ -d "${ZRAM_PATCH_BASE}/lz4k_oplus" ]; then
                cp -r "${ZRAM_PATCH_BASE}/lz4k_oplus" ./lib/ || echo "lz4k_oplus copy failed"
              fi
              LZ4KD_PATCH_PATH="${ZRAM_PATCH_BASE}/zram_patch/${{ env.SELECTED_KERNEL_VERSION }}/lz4kd.patch"
              if [ -f "$LZ4KD_PATCH_PATH" ]; then
                cp "$LZ4KD_PATCH_PATH" ./lz4kd.patch
                patch -p1 -F 3 < lz4kd.patch || echo "lz4kd patch failed for ${{ env.SELECTED_KERNEL_VERSION }}"
              else
                echo "lz4kd patch not found for ${{ env.SELECTED_KERNEL_VERSION }} at $LZ4KD_PATCH_PATH"
              fi
              LZ4K_OPLUS_PATCH_PATH="${ZRAM_PATCH_BASE}/zram_patch/${{ env.SELECTED_KERNEL_VERSION }}/lz4k_oplus.patch"
              if [ -f "$LZ4K_OPLUS_PATCH_PATH" ]; then
                cp "$LZ4K_OPLUS_PATCH_PATH" ./lz4k_oplus.patch
                patch -p1 -F 3 < lz4k_oplus.patch || echo "lz4k_oplus patch failed for ${{ env.SELECTED_KERNEL_VERSION }}"
              else
                echo "lz4k_oplus patch not found for ${{ env.SELECTED_KERNEL_VERSION }} at $LZ4K_OPLUS_PATCH_PATH"
              fi
              echo "ZRAM compression patches finished."
            else
              echo "Skipping ZRAM compression patches as use_zram is false."
            fi
          }
          apply_hide_stuff_patch() {
            echo "Applying hide stuff patch..."
            cd "$COMMON_DIR_PATH"
            HIDE_PATCH_FILE="${GITHUB_WORKSPACE}/SukiSU_patch/69_hide_stuff.patch"
            if [ -f "$HIDE_PATCH_FILE" ]; then
              cp "$HIDE_PATCH_FILE" ./hide_stuff.patch
              patch -p1 -F 3 < hide_stuff.patch || echo "Hide stuff patch failed"
            else
              echo "Hide stuff patch file not found: $HIDE_PATCH_FILE"
            fi
            echo "Hide stuff patch finished."
          }

          apply_susfs_patch &
          PID_SUSFS=$!
          apply_hooks_patch &
          PID_HOOKS=$!
          apply_zram_compression_patches &
          PID_ZRAM=$!
          apply_hide_stuff_patch &
          PID_HIDE=$!

          echo "Waiting for patch processes to complete..."
          FAIL=0
          wait $PID_SUSFS || { echo "SUSFS patching failed in background."; FAIL=1; }
          wait $PID_HOOKS || { echo "Hooks patching failed in background."; FAIL=1; }
          wait $PID_ZRAM || { echo "ZRAM patching failed in background."; FAIL=1; }
          wait $PID_HIDE || { echo "Hide stuff patching failed in background."; FAIL=1; }
          
          if [ "$FAIL" -eq 1 ]; then
            echo "One or more patch processes failed. Check logs."
            # exit 1 # 根据需要，如果任何补丁失败则可以选择退出
          else
            echo "All patch processes completed."
          fi

      - name: 配置ZRAM算法
        if: ${{ github.event.inputs.use_zram == 'true' }}
        run: |
          # ... (ZRAM配置逻辑保持不变，确保GKI_DEFCONFIG_PATH_ENV正确) ...
          CONFIG_FILE_PATH="${{ env.GKI_DEFCONFIG_PATH_ENV }}"
          echo "Configuring ZRAM algorithms in $CONFIG_FILE_PATH"
          if [ ! -f "$CONFIG_FILE_PATH" ]; then
            echo "Error: gki_defconfig not found at $CONFIG_FILE_PATH for ZRAM config"
            exit 1
          fi
          # (确保不重复添加或正确修改已存在的行)
          grep -qxF 'CONFIG_ZSMALLOC=y' "$CONFIG_FILE_PATH" || echo 'CONFIG_ZSMALLOC=y' >> "$CONFIG_FILE_PATH"
          sed -i 's/^CONFIG_ZSMALLOC=m$/CONFIG_ZSMALLOC=y/' "$CONFIG_FILE_PATH"
          grep -qxF 'CONFIG_ZRAM=y' "$CONFIG_FILE_PATH" || echo 'CONFIG_ZRAM=y' >> "$CONFIG_FILE_PATH"
          sed -i 's/^CONFIG_ZRAM=m$/CONFIG_ZRAM=y/' "$CONFIG_FILE_PATH"

          if [ "${{ env.SELECTED_KERNEL_VERSION }}" = "5.10" ]; then
            sed -i '/^CONFIG_MODULE_SIG=./d' "$CONFIG_FILE_PATH" # 删除旧的
            echo "CONFIG_MODULE_SIG=n" >> "$CONFIG_FILE_PATH"
            grep -qxF 'CONFIG_CRYPTO_LZO=y' "$CONFIG_FILE_PATH" || echo 'CONFIG_CRYPTO_LZO=y' >> "$CONFIG_FILE_PATH"
            grep -qxF 'CONFIG_ZRAM_DEF_COMP_LZ4KD=y' "$CONFIG_FILE_PATH" || echo 'CONFIG_ZRAM_DEF_COMP_LZ4KD=y' >> "$CONFIG_FILE_PATH"
          fi
          if [ "${{ env.SELECTED_ANDROID_VERSION }}" = "android14" ] || [ "${{ env.SELECTED_ANDROID_VERSION }}" = "android15" ]; then
            MODULES_BZL_PATH="${{ env.CONFIG }}/common/modules.bzl"
            if [ -f "$MODULES_BZL_PATH" ]; then
              sed -i 's/"drivers\/block\/zram\/zram\.ko",//g; s/"mm\/zsmalloc\.ko",//g' "$MODULES_BZL_PATH"
            fi
            sed -i '/^CONFIG_MODULE_SIG_FORCE=./d' "$CONFIG_FILE_PATH"
            echo "CONFIG_MODULE_SIG_FORCE=n" >> "$CONFIG_FILE_PATH"
          elif [ "${{ env.SELECTED_KERNEL_VERSION }}" = "5.10" ] || [ "${{ env.SELECTED_KERNEL_VERSION }}" = "5.15" ]; then
            GKI_MODULES_FILE="${{ env.CONFIG }}/common/android/gki_aarch64_modules"
            # 创建空文件或清空已存在的文件
            echo -n > "$GKI_MODULES_FILE"
          fi
          if grep -q "^CONFIG_ZSMALLOC=y$" "$CONFIG_FILE_PATH" && grep -q "^CONFIG_ZRAM=y$" "$CONFIG_FILE_PATH"; then
            echo "CONFIG_CRYPTO_LZ4HC=y" >> "$CONFIG_FILE_PATH"
            echo "CONFIG_CRYPTO_LZ4K=y" >> "$CONFIG_FILE_PATH"
            echo "CONFIG_CRYPTO_LZ4KD=y" >> "$CONFIG_FILE_PATH"
            echo "CONFIG_CRYPTO_842=y" >> "$CONFIG_FILE_PATH"
            echo "CONFIG_CRYPTO_LZ4K_OPLUS=y" >> "$CONFIG_FILE_PATH"
          fi
          # 去重并排序，保持配置文件整洁
          sort -u "$CONFIG_FILE_PATH" -o "$CONFIG_FILE_PATH"
          echo "ZRAM algorithm configuration finished."


      - name: 配置SUSFS及附加功能
        run: |
          # ... (SUSFS及附加功能配置逻辑保持不变，确保GKI_DEFCONFIG_PATH_ENV正确) ...
          GKI_DEFCONFIG_PATH="${{ env.GKI_DEFCONFIG_PATH_ENV }}"
          # ... (其他 build_config 路径定义)
          BUILD_CONFIG_GKI_PATH="${GITHUB_WORKSPACE}/${{ env.CONFIG }}/common/build.config.gki"
          BUILD_CONFIG_BAZEL_PATH="${GITHUB_WORKSPACE}/${{ env.CONFIG }}/common/build.config.gki.aarch64"
          BUILD_CONFIG_GENERIC_PATH="${GITHUB_WORKSPACE}/${{ env.CONFIG }}/common/build.config"
          BUILD_SCRIPT_PATH_CHECK_CONTEXTUAL="${GITHUB_WORKSPACE}/${{ env.CONFIG }}/build/build.sh"

          echo "Configuring SUSFS and additional features in $GKI_DEFCONFIG_PATH"
          if [ ! -f "$GKI_DEFCONFIG_PATH" ]; then
            echo "Error: gki_defconfig not found at $GKI_DEFCONFIG_PATH for SUSFS config"
            exit 1
          fi
          
          configs_to_set=(
            "CONFIG_KSU=y" "CONFIG_KSU_SUSFS_SUS_SU=n" "CONFIG_KSU_MANUAL_HOOK=y"
            "CONFIG_TMPFS_XATTR=y" "CONFIG_TMPFS_POSIX_ACL=y"
            "CONFIG_IP_NF_TARGET_TTL=y" "CONFIG_IP6_NF_TARGET_HL=y" "CONFIG_IP6_NF_MATCH_HL=y"
            "CONFIG_TCP_CONG_ADVANCED=y" "CONFIG_TCP_CONG_BBR=y" "CONFIG_NET_SCH_FQ=y"
            "CONFIG_TCP_CONG_BIC=n" "CONFIG_TCP_CONG_WESTWOOD=n" "CONFIG_TCP_CONG_HTCP=n"
            "CONFIG_KSU_SUSFS=y" "CONFIG_KSU_SUSFS_HAS_MAGIC_MOUNT=y" "CONFIG_KSU_SUSFS_SUS_PATH=y"
            "CONFIG_KSU_SUSFS_SUS_MOUNT=y" "CONFIG_KSU_SUSFS_AUTO_ADD_SUS_KSU_DEFAULT_MOUNT=y"
            "CONFIG_KSU_SUSFS_AUTO_ADD_SUS_BIND_MOUNT=y" "CONFIG_KSU_SUSFS_SUS_KSTAT=y"
            "CONFIG_KSU_SUSFS_SUS_OVERLAYFS=n" "CONFIG_KSU_SUSFS_TRY_UMOUNT=y"
            "CONFIG_KSU_SUSFS_AUTO_ADD_TRY_UMOUNT_FOR_BIND_MOUNT=y" "CONFIG_KSU_SUSFS_SPOOF_UNAME=y"
            "CONFIG_KSU_SUSFS_ENABLE_LOG=y" "CONFIG_KSU_SUSFS_HIDE_KSU_SUSFS_SYMBOLS=y"
            "CONFIG_KSU_SUSFS_SPOOF_CMDLINE_OR_BOOTCONFIG=y" "CONFIG_KSU_SUSFS_OPEN_REDIRECT=y"
          )
          if [[ "${{ env.EFFECTIVE_USE_KPM }}" == "true" ]]; then
            configs_to_set+=("CONFIG_KPM=y")
          else
            configs_to_set+=("CONFIG_KPM=n") # 明确禁用
          fi
          
          for config in "${configs_to_set[@]}"; do
            key=$(echo "$config" | cut -d'=' -f1)
            sed -i "/^${key}=/d" "$GKI_DEFCONFIG_PATH"
            sed -i "/^# ${key} is not set/d" "$GKI_DEFCONFIG_PATH"
            echo "$config" >> "$GKI_DEFCONFIG_PATH"
          done
          sort -u "$GKI_DEFCONFIG_PATH" -o "$GKI_DEFCONFIG_PATH"

          build_config_files=("$BUILD_CONFIG_GKI_PATH" "$BUILD_CONFIG_BAZEL_PATH" "$BUILD_CONFIG_GENERIC_PATH")
          for file_path in "${build_config_files[@]}"; do
            if [ -f "$file_path" ]; then
              sed -i 's/check_defconfig//g' "$file_path"
              echo "Removed 'check_defconfig' from $file_path (if present)."
            fi
          done

          # cd "${{ env.CONFIG }}" # 切换到内核源码根目录上下文
          # if [ ! -f "$BUILD_SCRIPT_PATH_CHECK_CONTEXTUAL" ]; then # Bazel构建
          #   TARGET_BAZEL_CONFIG_FILE=""
          #   if [ -f "./common/build.config.gki.aarch64" ]; then
          #       TARGET_BAZEL_CONFIG_FILE="./common/build.config.gki.aarch64"
          #   elif [ -f "./common/build.config" ]; then
          #       TARGET_BAZEL_CONFIG_FILE="./common/build.config"
          #   fi
          #   if [ -n "$TARGET_BAZEL_CONFIG_FILE" ]; then
          #       grep -qxF "SKIP_KMI_STRICT_MODE_CHECK=1" "$TARGET_BAZEL_CONFIG_FILE" || echo "SKIP_KMI_STRICT_MODE_CHECK=1" >> "$TARGET_BAZEL_CONFIG_FILE"
          #       echo "Ensured SKIP_KMI_STRICT_MODE_CHECK=1 in $TARGET_BAZEL_CONFIG_FILE"
          #   else
          #       echo "Warning: Could not find a suitable Bazel build config file to set SKIP_KMI_STRICT_MODE_CHECK."
          #   fi
          # fi
          # cd "$GITHUB_WORKSPACE" # 返回工作区
          #  (上面的 SKIP_KMI_STRICT_MODE_CHECK 逻辑需要仔细确认上下文和文件路径)
          # 为简化，假设此逻辑在 build.config.* 文件中已被正确处理，或在编译命令中通过参数覆盖
          echo "SUSFS and additional features configuration finished."


      - name: 配置内核版本参数
        working-directory: ./${{ env.CONFIG }} # 确保在正确的目录下
        run: |
          # ... (内核版本参数配置逻辑保持不变，依赖 GKI_DEFCONFIG_PATH_ENV) ...
          GKI_DEFCONFIG_FILE_PATH="../common/arch/arm64/configs/gki_defconfig" # 相对路径
          # 或者使用绝对路径: GKI_DEFCONFIG_FILE_PATH="${{ env.GKI_DEFCONFIG_PATH_ENV }}"
          # 使用 env.GKI_DEFCONFIG_PATH_ENV 更可靠
          GKI_DEFCONFIG_FILE_PATH_ACTUAL="${{ env.GKI_DEFCONFIG_PATH_ENV }}"
          SETLOCALVERSION_SCRIPT="./common/scripts/setlocalversion"

          echo "Configuring kernel version parameters in $GKI_DEFCONFIG_FILE_PATH_ACTUAL..."

          if [ -f "$GKI_DEFCONFIG_FILE_PATH_ACTUAL" ]; then
            sed -i '/^CONFIG_LOCALVERSION=/d' "$GKI_DEFCONFIG_FILE_PATH_ACTUAL"
            echo 'CONFIG_LOCALVERSION=""' >> "$GKI_DEFCONFIG_FILE_PATH_ACTUAL"
            sed -i '/^CONFIG_LOCALVERSION_AUTO=/d' "$GKI_DEFCONFIG_FILE_PATH_ACTUAL"
            echo '# CONFIG_LOCALVERSION_AUTO is not set' >> "$GKI_DEFCONFIG_FILE_PATH_ACTUAL"
            echo "Cleared CONFIG_LOCALVERSION and CONFIG_LOCALVERSION_AUTO in gki_defconfig."
          else
            echo "Warning: gki_defconfig not found at $GKI_DEFCONFIG_FILE_PATH_ACTUAL for version param config."
          fi

          if [ -f "$SETLOCALVERSION_SCRIPT" ]; then
            if [[ -n "${{ env.FINAL_KERNEL_LOCAL_VERSION }}" ]]; then
              echo '#!/bin/sh' > "$SETLOCALVERSION_SCRIPT"
              echo 'echo "${{ env.FINAL_KERNEL_LOCAL_VERSION }}"' >> "$SETLOCALVERSION_SCRIPT"
              chmod +x "$SETLOCALVERSION_SCRIPT"
              echo "Set setlocalversion script to output: ${{ env.FINAL_KERNEL_LOCAL_VERSION }}"
            else
              sed -i 's/-dirty//g' "$SETLOCALVERSION_SCRIPT" # 移除 -dirty
              echo "FINAL_KERNEL_LOCAL_VERSION is empty. Ensured '-dirty' is removed from setlocalversion script."
            fi
          else
            echo "Warning: setlocalversion script not found at $SETLOCALVERSION_SCRIPT."
          fi
          # (移除 ABI 相关文件和修改 Kleaf stamp.bzl 的逻辑保持不变)
          BUILD_SCRIPT_PATH_CHECK="./build/build.sh"
          if [ ! -f "$BUILD_SCRIPT_PATH_CHECK" ]; then # Bazel/Kleaf 构建
            COMMON_BAZEL_PATH_CHECK="./common/BUILD.bazel"
            KLEAF_STAMP_BZL_PATH_CHECK="./build/kernel/kleaf/impl/stamp.bzl"
            if [ -f "$COMMON_BAZEL_PATH_CHECK" ]; then
              sed -i '/^[[:space:]]*"protected_exports_list"[[:space:]]*:[[:space:]]*"android\/abi_gki_protected_exports_aarch64",$/d' "$COMMON_BAZEL_PATH_CHECK"
              echo "Attempted to remove protected_exports_list from $COMMON_BAZEL_PATH_CHECK."
            fi
            rm -rf ./common/android/abi_gki_protected_exports_*
            echo "Removed abi_gki_protected_exports files from ./common/android/."
            if [ -f "$KLEAF_STAMP_BZL_PATH_CHECK" ]; then
              sed -i "/stable_scmversion_cmd/s/-maybe-dirty//g" "$KLEAF_STAMP_BZL_PATH_CHECK"
              echo "Removed '-maybe-dirty' from Kleaf stamp.bzl."
            fi
          fi
          echo "Kernel version parameter configuration finished."


      # 四、内核配置校验增强
      - name: 校验关键内核配置
        run: |
          GKI_DEFCONFIG_TO_CHECK="${{ env.GKI_DEFCONFIG_PATH_ENV }}"
          echo "Validating kernel config options in: $GKI_DEFCONFIG_TO_CHECK"
          if [ ! -f "$GKI_DEFCONFIG_TO_CHECK" ]; then
            echo "::error::Kernel defconfig file not found for validation: $GKI_DEFCONFIG_TO_CHECK"
            exit 1
          fi
          
          MISSING_CONFIGS=0
          
          # 校验 KSU (如果您的 SukiSU 确实依赖 CONFIG_KSU，而不是其他特定于 SukiSU 的配置项)
          # KernelSU/SukiSU 通常有自己的 CONFIG_KSU 或类似项
          if ! grep -q "^CONFIG_KSU=y$" "$GKI_DEFCONFIG_TO_CHECK"; then
            echo "::error::CONFIG_KSU is not enabled or not set to 'y' in $GKI_DEFCONFIG_TO_CHECK!"
            MISSING_CONFIGS=1
          else
            echo "CONFIG_KSU=y validated."
          fi

          # 校验 ZRAM (如果启用了 use_zram 输入)
          if [[ "${{ github.event.inputs.use_zram }}" == "true" ]]; then
            if ! grep -q "^CONFIG_ZRAM=y$" "$GKI_DEFCONFIG_TO_CHECK"; then
              echo "::error::CONFIG_ZRAM is not enabled or not set to 'y' in $GKI_DEFCONFIG_TO_CHECK, but use_zram input is true!"
              MISSING_CONFIGS=1
            else
              echo "CONFIG_ZRAM=y validated (as use_zram is true)."
            fi
          fi
          
          # 您可以根据需要添加更多关键配置的校验
          # 例如: grep -q "^CONFIG_SOME_FEATURE=y$" "$GKI_DEFCONFIG_TO_CHECK" || { echo "::error::CONFIG_SOME_FEATURE not enabled!"; MISSING_CONFIGS=1; }

          if [ "$MISSING_CONFIGS" -ne 0 ]; then
            echo "::error::One or more critical kernel configurations are missing or incorrect. Please check the defconfig and earlier configuration steps."
            exit 1
          fi
          echo "Kernel configuration validation passed."

      - name: 编译内核 (带重试和性能分析)
        uses: nick-fields/retry@v3
        env:
          # 将环境变量传递给命令执行上下文
          CONFIG_DIR: ${{ env.CONFIG }} # 内核源码和配置所在目录 (例如: android12-5.10-168)
          # BAZEL_OPTIMIZATION_FLAGS 来自顶层作业的env定义
          BAZEL_PROFILE_PATH_IN_WORKSPACE: ${{ github.workspace }}/${{ env.BAZEL_PROFILE_FILENAME }} # Bazel profile文件的完整路径
        with:
          timeout_minutes: 75 # 编译超时时间
          max_attempts: 2     # 最大重试次数
          retry_on: timeout   # 仅在超时时重试
          command: |
            set -e # 出错时立即退出
            set -x # 打印实际执行的命令

            cd "${CONFIG_DIR}" # 进入内核源码和配置所在目录
            
            BUILD_SCRIPT_PATH="./build/build.sh" # 旧版GKI构建脚本的路径
            BAZEL_DISK_CACHE_PATH="/home/runner/.cache/bazel_disk_cache" # Bazel磁盘缓存路径
            mkdir -p "$BAZEL_DISK_CACHE_PATH"

            # 使用 /usr/bin/time -v 进行详细的资源使用和时间统计
            if [ -f "$BUILD_SCRIPT_PATH" ]; then
              echo "Using legacy build.sh script..."
              # 对于 build.sh，环境变量应在命令执行前设置好。
              # /usr/bin/time -v 用于计时 ./build/build.sh 的执行。
              LTO=thin \
              SYSTEM_DLKM_RE_SIGN=0 \
              BUILD_SYSTEM_DLKM=0 \
              KMI_SYMBOL_LIST_STRICT_MODE=0 \
              BUILD_CONFIG=common/build.config.gki.aarch64 \
              CC="/usr/bin/ccache clang" \
              /usr/bin/time -v ./build/build.sh || exit 1 # 修正点：环境变量在前，time -v build.sh 在后
            else
              echo "Using Bazel build system..."
              # 构建 Bazel 命令字符串，整合优化参数
              # BAZEL_OPTIMIZATION_FLAGS 来自作业的env块
              BAZEL_CMD="tools/bazel build \
                --disk_cache=${BAZEL_DISK_CACHE_PATH} \
                --config=fast \
                --lto=thin \
                --profile=${BAZEL_PROFILE_PATH_IN_WORKSPACE} \
                ${BAZEL_OPTIMIZATION_FLAGS} \
                //common:kernel_aarch64_dist"
              
              echo "Executing Bazel command: $BAZEL_CMD"
              /usr/bin/time -v $BAZEL_CMD || exit 1
            fi
            
            echo "Ccache statistics after build:"
            ccache --show-stats
            
            # 如果设置了CCACHE_LOGFILE，显示日志文件大小或最后几行
            if [ -n "${CCACHE_LOGFILE}" ] && [ -f "${CCACHE_LOGFILE}" ]; then
              echo "Ccache log file (${CCACHE_LOGFILE}) size: $(du -sh ${CCACHE_LOGFILE} | cut -f1)"
              echo "Last 10 lines of ccache log:"
              tail -n 10 "${CCACHE_LOGFILE}" || true
            fi

            # 如果生成了Bazel profile，提示其位置
            if [ -f "${BAZEL_PROFILE_PATH_IN_WORKSPACE}" ]; then
                echo "Bazel profile generated at: ${BAZEL_PROFILE_PATH_IN_WORKSPACE}"
            else
                echo "Bazel profile file not found at ${BAZEL_PROFILE_PATH_IN_WORKSPACE} (this is normal if not a Bazel build, profiling failed, or build.sh was used)."
            fi

      - name: 修补内核映像 (KPM A12/A13)
        # ... (KPM 修补逻辑保持不变) ...
        if: env.EFFECTIVE_USE_KPM == 'true' && (env.SELECTED_ANDROID_VERSION == 'android12' || env.SELECTED_ANDROID_VERSION == 'android13') && env.SELECTED_KERNEL_VERSION != '6.6'
        run: |
          IMAGE_DIR_PATH="${{ env.CONFIG }}/out/${{ env.SELECTED_ANDROID_VERSION }}-${{ env.SELECTED_KERNEL_VERSION }}/dist"
          if [ -d "$IMAGE_DIR_PATH" ] && [ -f "$IMAGE_DIR_PATH/Image" ]; then
            cd "$IMAGE_DIR_PATH"
            curl -LSs "https://raw.githubusercontent.com/ShirkNeko/SukiSU_patch/refs/heads/main/kpm/patch_linux" -o patch_kpm
            chmod +x patch_kpm
            ./patch_kpm
            if [ -f "oImage" ]; then
              mv Image Image.orig_kpm; mv oImage Image
              echo "KPM patched for A12/A13 Image."
            else echo "Warning: KPM patching for A12/A13 did not produce oImage."; fi
          else echo "Warning: Image directory or Image file not found for A12/A13 KPM patching at $IMAGE_DIR_PATH"; fi

      - name: 修补内核映像 (KPM A14/A15)
        # ... (KPM 修补逻辑保持不变) ...
        if: env.EFFECTIVE_USE_KPM == 'true' && (env.SELECTED_ANDROID_VERSION == 'android14' || env.SELECTED_ANDROID_VERSION == 'android15') && env.SELECTED_KERNEL_VERSION != '6.6'
        run: |
          IMAGE_DIR_PATH="${{ env.CONFIG }}/bazel-bin/common/kernel_aarch64/" # Bazel 输出路径
          if [ -d "$IMAGE_DIR_PATH" ] && [ -f "$IMAGE_DIR_PATH/Image" ]; then
            cd "$IMAGE_DIR_PATH"
            curl -LSs "https://raw.githubusercontent.com/ShirkNeko/SukiSU_patch/refs/heads/main/kpm/patch_linux" -o patch_kpm
            chmod +x patch_kpm
            ./patch_kpm
            if [ -f "oImage" ]; then
              mv Image Image.orig_kpm; mv oImage Image
              echo "KPM patched for A14/A15 Image."
            else echo "Warning: KPM patching for A14/A15 did not produce oImage."; fi
          else echo "Warning: Image directory or Image file not found for A14/A15 KPM patching at $IMAGE_DIR_PATH"; fi


      - name: 复制内核映像至AnyKernel3
        run: |
          # ... (复制内核映像逻辑保持不变) ...
          IMAGE_SOURCE_PATH=""
          # 检查旧版构建输出路径
          LEGACY_IMAGE_PATH="./${{ env.CONFIG }}/out/${{ env.SELECTED_ANDROID_VERSION }}-${{ env.SELECTED_KERNEL_VERSION }}/dist/Image"
          # 检查Bazel构建输出路径
          BAZEL_IMAGE_PATH="./${{ env.CONFIG }}/bazel-bin/common/kernel_aarch64/Image"

          if [ -f "$LEGACY_IMAGE_PATH" ]; then
            IMAGE_SOURCE_PATH="$LEGACY_IMAGE_PATH"
          elif [ -f "$BAZEL_IMAGE_PATH" ]; then
            IMAGE_SOURCE_PATH="$BAZEL_IMAGE_PATH"
          else
            echo "::error::Compiled Image file not found in expected legacy or Bazel output paths."
            ls -R "./${{ env.CONFIG }}/out/" || true # 列出out目录内容辅助调试
            ls -R "./${{ env.CONFIG }}/bazel-bin/" || true # 列出bazel-bin目录内容辅助调试
            exit 1
          fi
          echo "Attempting to copy Image from: $IMAGE_SOURCE_PATH"
          if [ ! -d "./AnyKernel3" ]; then
            echo "::error::AnyKernel3 directory not found. Cannot copy Image."
            exit 1
          fi
          cp "$IMAGE_SOURCE_PATH" ./AnyKernel3/Image
          echo "Image successfully copied to AnyKernel3."


      - name: 上传AnyKernel3刷机包 (Artifact)
        uses: actions/upload-artifact@v4
        with:
          name: |
            ${{ (env.SUKI_VERSION_NUM != 'NoVer' && env.SUKI_VERSION_NUM != '' && env.SUKI_VERSION_NUM != '00000') &&
                format('AnyKernel3_SukiSUUltra_{0}_{1}-{2}{3}', env.SUKI_VERSION_NUM, env.SELECTED_KERNEL_VERSION, env.SELECTED_SUB_LEVEL, env.ARTIFACT_NAME_SUFFIX_PART) ||
                format('AnyKernel3_SukiSU_{0}_{1}-{2}{3}', 'NoVer', env.SELECTED_KERNEL_VERSION, env.SELECTED_SUB_LEVEL, env.ARTIFACT_NAME_SUFFIX_PART) }}
          path: ./AnyKernel3
          if-no-files-found: error

      - name: 上传日志文件 (ccache, bazel_profile)
        if: always() # 总是执行，即使前面的步骤失败
        uses: actions/upload-artifact@v4
        with:
          name: build-logs-${{ env.SELECTED_ANDROID_VERSION }}-${{ env.SELECTED_KERNEL_VERSION }}-${{ github.run_id }}
          path: |
            ${{ env.CCACHE_LOGFILE }}
            ${{ github.workspace }}/${{ env.BAZEL_PROFILE_FILENAME }}
            # 您可以添加更多需要上传的日志文件路径，例如内核构建日志
            # 例如：${{ env.CONFIG }}/out/dist/logs/ # (路径需确认)
          if-no-files-found: ignore # 如果日志文件不存在则忽略

      - name: 准备 Release 输出信息
        id: prepare_release_outputs
        shell: bash
        run: |
          # ... (Release 输出信息准备逻辑保持不变) ...
          _suki_ver_num_for_name_prep="${{ env.SUKI_VERSION_NUM }}"
          _kernel_ver="${{ env.SELECTED_KERNEL_VERSION }}"
          _sub_level="${{ env.SELECTED_SUB_LEVEL }}"
          _suffix_part="${{ env.ARTIFACT_NAME_SUFFIX_PART }}"
          _artifact_name_for_upload_internal=""

          if [[ "$_suki_ver_num_for_name_prep" != "NoVer" && "$_suki_ver_num_for_name_prep" =~ ^[0-9]+$ && "$_suki_ver_num_for_name_prep" != "00000" && "$_suki_ver_num_for_name_prep" != "10000" ]]; then
            _artifact_name_for_upload_internal="AnyKernel3_SukiSUUltra_${_suki_ver_num_for_name_prep}_${_kernel_ver}-${_sub_level}${_suffix_part}"
          else
            _artifact_name_for_upload_internal="AnyKernel3_SukiSU_NoVer_${_kernel_ver}-${_sub_level}${_suffix_part}"
          fi
          _artifact_name_cleaned_for_output=$(echo "$_artifact_name_for_upload_internal" | sed 's/[^a-zA-Z0-9._-]/-/g') # 清理特殊字符
          echo "artifact_name_for_release=${_artifact_name_cleaned_for_output}" >> "$GITHUB_OUTPUT"

          _new_release_base_name="SukiSUUltra"
          _final_release_title=""
          _final_release_tag=""
          if [[ "$_suki_ver_num_for_name_prep" != "NoVer" && "$_suki_ver_num_for_name_prep" =~ ^[0-9]+$ && "$_suki_ver_num_for_name_prep" != "00000" && "$_suki_ver_num_for_name_prep" != "10000" ]]; then
            _final_release_title="${_new_release_base_name}-${_suki_ver_num_for_name_prep}_${_kernel_ver}-${_sub_level}"
            _final_release_tag="${_new_release_base_name}-${_suki_ver_num_for_name_prep}_${_kernel_ver}-${_sub_level}"
          else
            _actual_suffix_for_fallback="${_suffix_part}"
            if [[ -z "$_actual_suffix_for_fallback" && "${{ github.event.inputs.custom_version_suffix }}" == "" ]]; then # 仅当自定义后缀也为空时才使用日期
               _actual_suffix_for_fallback="-$(date +%Y%m%d)"
            fi
            _final_release_title="${_new_release_base_name}-NoVer_${_kernel_ver}-${_sub_level}${_actual_suffix_for_fallback}"
            _final_release_tag="${_new_release_base_name}-NoVer_${_kernel_ver}-${_sub_level}${_actual_suffix_for_fallback}"
          fi
          _final_release_tag_cleaned=$(echo "$_final_release_tag" | sed 's/[^a-zA-Z0-9._-]/-/g') # 清理特殊字符
          _final_release_title_cleaned="${_final_release_title}"
          echo "release_tag_name=${_final_release_tag_cleaned}" >> "$GITHUB_OUTPUT"
          echo "release_title_name=${_final_release_title_cleaned}" >> "$GITHUB_OUTPUT"

  create_release:
    name: 创建 GitHub Release
    needs: build_kernel
    permissions:
      contents: write
    runs-on: ubuntu-latest
    if: success() && github.event.inputs.upload_to_release == 'true'
    steps:
      - name: 安装 zip 工具
        # 如果使用自定义Docker容器并且已包含zip，则此步骤应被移除或注释掉
        run: sudo apt-get update && sudo apt-get install -y zip

      - name: 下载内核刷机包 (Artifact)
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.build_kernel.outputs.artifact_name }}
          path: downloaded_artifact/ # 下载到子目录

      - name: 准备刷机包并设置路径
        id: package_kernel
        shell: bash
        run: |
          cd downloaded_artifact
          # artifact_name 来自 needs.build_kernel.outputs.artifact_name，它本身不包含 .zip
          zip_file_name_base="${{ needs.build_kernel.outputs.artifact_name }}"
          zip_file_name_final="${zip_file_name_base}.zip"
          
          if [ -z "$(ls -A .)" ]; then
            echo "::error title=打包失败::downloaded_artifact 目录为空，无法创建 ${zip_file_name_final}"
            exit 1
          fi
          echo "Creating zip file: ../${zip_file_name_final} from contents of $(pwd)"
          zip -r9 "../${zip_file_name_final}" .
          cd ..
          
          if [ ! -f "${zip_file_name_final}" ]; then
            echo "::error title=打包失败::未能创建 ${zip_file_name_final}"
            exit 1
          fi
          echo "Packaged zip file: ${zip_file_name_final}"
          echo "packaged_zip=${zip_file_name_final}" >> $GITHUB_OUTPUT

      - name: 创建 Release 并上传刷机包
        uses: ncipollo/release-action@v1
        with:
          artifacts: ${{ steps.package_kernel.outputs.packaged_zip }}
          tag: ${{ needs.build_kernel.outputs.release_tag }}
          name: ${{ needs.build_kernel.outputs.release_title }}
          body: |
            自动构建的内核发行版。

            **核心信息:**
            - 内核版本构建输入: `${{ github.event.inputs.kernel_to_build }}`
            - SukiSU 版本 (计算): `${{ needs.build_kernel.outputs.sukisu_version_from_build_job }}`
            - SukiSU 功能分支: `${{ github.event.inputs.kernelsu_branch }}`
            - 自定义版本后缀 (如有): `${{ github.event.inputs.custom_version_suffix == '' && '仿官方随机生成' || format('自定义: {0}', github.event.inputs.custom_version_suffix) }}`
            - 内核名 (LOCALVERSION): `${{ needs.build_kernel.outputs.parsed_kernel_version_output }}.${{ needs.build_kernel.outputs.parsed_sub_level_output }}${{ needs.build_kernel.outputs.final_kernel_local_version_output }}`
            - 构建日期: `${{ needs.build_kernel.outputs.current_build_date_formatted_output }}`

            **构建选项:**
            - 使用ZRAM: `${{ github.event.inputs.use_zram }}`
            - 使用KPM: `${{ env.EFFECTIVE_USE_KPM }}`

            ---
            *SHA: `${{ github.sha }}`*
            *构建ID: `${{ github.run_id }}`*
          token: ${{ secrets.GITHUB_TOKEN }}
          allowUpdates: true
          # draft: false # 是否创建为草稿
          # prerelease: false # 是否标记为预发布